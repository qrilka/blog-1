---
layout: post
title: Парадигмы? Не, не слышал...
created: 1350651932
categories:
- !binary |-
  0J/RgNC+0LPRgNCw0LzQvNC40YDQvtCy0LDQvdC40LU=
- !binary |-
  0KTQuNC70L7RgdC+0YTQuNGP
---
Навеяло... Прочитал тут одну статью (желающие могут ознакомиться <strong><a href="http://habrahabr.ru/post/147927/">здесь</a></strong>), про парадигму ООП. Вы, очевидно, в курсе, что парадигма ООП в последние годы подвергается серьёзной критике. Дошло уже до того, что сама идея объекта названа фундаментально ошибочной. Ну и, как обычно, критика сия порождает тонны холиваров как в РуНете, так и во всём остальном Нете.

А я взглянул на это с другой стороны.... Вот, скажем, такой код:
<cpp>
sregex part_1_regex( traits_of_file const& traits ) {
    return convert( "sizeof" ).based_on( traits )
           >> indent()
           >> convert( "(" ).based_on( traits )
           >> indent();
}
</cpp>Как бы вы охарактеризовали его с точки зрения парадигм? Это что, ООП? Ну вроде бы да, ведь в функцию в качестве единственного аргумента передаётся объект типа <strong>traits_of_file</strong>. С другой стороны, в теле функции присутствует функтор, следовательно пахнет уже ФП. Кроме того, функции indent() возвращают объекты типа <strong>boost::xpressive::sregex</strong>, но мы не видим эти объекты, они присутствуют тут как бы незримо. И в довершении мы возвращаем безымянный объект того же типа <strong>boost::xpressive::regex</strong>...

Можно было бы сказать: "Здесь имеют место различные парадигмы". И это действительно так, мы видим тут три парадигмы (включая старую добрую процедурную), но я подумал о другом... Друзья, а какая, собственно, разница? Какая разница, ООП тут, или ФП, или ещё чего-нибудь? Зачем вообще нужны эти дополнительные характеристики?

Вот, скажем, наследование и полиморфизм, называемые китами ООП. Я вам честно признаюсь: я не знаю тонкостей наследования (скажем, виртуального) и едва ли смог бы пройти замудрёный тест на тему полиморфизма. Однако никакой ущербности в себе из-за этого не ощущаю. Знаете почему? Потому что с определённого момента (особенно с того времени, как начал работать на самого себя) я вдруг начал понимать: <strong>я не обязан знать всё это</strong>.

Я обязан уметь только одно: создавать код, который будет решать поставленную перед программным продуктом задачу. Точка. Обязан ли я использовать наследование для достижения этой цели? Ничего подобного. Обязан ли я на каждом шагу использовать шаблоны? Нет. Обязан ли я делать функтором всё и вся? Едва ли...

Мне кажется, многие программисты слишком фокусируются на парадигменном вопросе. Кроме того, многих из них так и подмывает возвыситься над другими только из-за того, что он "так круто умеет использовать множественное наследование". Друзья! Если мы и можем хвалиться, то не тем, что знаем парадигму А или Б, а тем, что создаём программные решения, полезные для людей. Это главное, и всегда будет главным.
