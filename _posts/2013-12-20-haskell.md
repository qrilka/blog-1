---
layout: post
title: 'Haskell: о лямбда-функциях'
created: 1387534949
categories:
- haskell
---
<!--break-->
Помню как в школе я довольно долго не мог понять, что же такое функция. Да, я уже решал многие задания с использованием функций, да, уже рисовал разнообразные графики (помните эти прелестные дуги на тетрадном листе в клеточку?), но при этом не мог бы объяснить ребёнку, что такое функция как <em>понятие</em>. А памятуя о мудрых словах Эйнштейна, если вы не можете объяснить некую идею пятилетнему ребёнку, значит вы и сами её не понимаете...

А ведь понятие-то оказалось предельно простым:

<strong>Функция - это описание зависимости чего-то от чего-то.</strong>

Всё. Если у нас есть описание того, <em>как</em> конкретное входное значение определяет конкретное выходное значение - значит это описание и есть функция.

Однако в мире языка C (и подобных ему языков) функция никогда не ассоциировалась с таким определением. Напротив, функция там есть не что иное, как <em>подпрограмма</em>, а имя функции есть не что иное, как указатель на первую инструкцию этой подпрограммы.

Кроме того, функция в C является глобальной в рамках текущей единицы трансляции. И поэтому вызов функции - это как бы "глобальный <strong><code>goto</code></strong>" в её тело (с последующим возвратом из него). Именно поэтому функция в языке C не может быть безымянной, потому что иначе её невозможно было бы вызывать.

Всё это я напоминаю вам для того, чтобы, продолжив чтение этой заметки, вы увидели, насколько концепция &lambda;-функций отличается от концепции функций в языке C.

<h3>Так что же это за лямбды такие?</h3>

В основе идеи &lambda;-функций лежит &lambda;-исчисление, названное так по имени этой красивой греческой буквы. У понятия &lambda;-исчисления довольно-таки долгая академическая история, нам нет смысла её здесь разбирать по косточкам. Нас интересует лишь суть, поэтому сразу пример.

Представим себе, что нам нужна функция, принимающая некое целочисленное значение и возвращающая квадрат этого значения. Причём функция именно в том самом, математическом смысле. Как бы мы могли это отобразить? Примерно так:

<cpp>
5 -> f -> 25
</cpp>

Итак, подаём на вход значение 5, а на выходе получаем 25. Проще некуда. Но как же нам записать внутренности функции <code>f</code>? Ну, например, так:

<cpp>
5 -> (x * x) -> 25
</cpp>

Тут тоже всё ясно: поданный на вход аргумент умножается сам на себя. 

Ну а теперь главный вопрос: как эту функцию описать <em>формально</em>, или <em>унифицированно</em>? Вот тут-то на сцену и выходит &lambda;-исчисление, ибо оно как раз и предлагает такой вот унифицированный способ записи функции. 

Вот &lambda;-выражение для нашей функции:

<pre>
&lambda;x.x*x
</pre>

Буква &lambda; - это признак &lambda;-функции. А читать это выражение следует примерно так: 

&lambda;-функция от одного аргумента <code>x</code>, умножающая этот аргумент сам на себя.

Таким образом, выражение до разделяющей точки:

<strong><pre>
&lambda;x
</pre></strong>

это список аргументов (в данном случае он один), а выражение после разделяющей точки:

<strong><pre>
x*x
</pre></strong>

это "тело" функции, описывающее ту самую зависимость выходного значения от значения входного.

Как видите, весьма простое и элегантное описание. Как говорится, ничего лишнего.

Обратите также внимание на то, что здесь нет имени. Особенностью &lambda;-функции является её безымянность. Почему? Потому что имя ей не нужно. И это принципиально отличает её от функции в языке C, потому что там я могу обратиться к функции не иначе, как через её имя (даже вызов через указатель всё равно требует хотя бы единократное использование имени функции). 

<h3>Ну хорошо, а как это будет выглядеть в коде?</h3>

&lambda;-функции присутствуют во многих языках программирования. Но есть один язык, в котором синтаксис &lambda;-выражения максимально приближен к приведённому здесь математическому. Угадайте с трёх раз, о каком языке я говорю... :)

Итак, вот наша функция в Haskell:

<hs>
\x -> x*x
</hs>

Ну, что я говорил? Прямое сходство. Ведь даже обратный слэш вначале подходит как нельзя лучше: рассматривайте его как "спинку" буквы &lambda;. Фактически, единственное отличие - это замена точки стрелочкой, потому что символ '<code>-></code>' присущ языку Haskell как признак (любой) функции. Нда-с, сразу чувствуется, что язык Haskell создал математик.

А теперь, вероятно, вас интересует, как же можно <em>вызывать</em> такую функцию? Вероятно, мой ответ удивит вас, но &lambda;-функции, строго говоря, не вызывают.

Да-да, я уже вижу расширающиеся от удивления глаза. Точно такие же были и у меня, когда я впервые прочитал об этом. Но на самом деле здесь имеет место лишь игра слов. А для того, чтобы всё встало на свои места, мы опять вынуждены на пару минут вернуться в математику.

Идея &lambda;-функции базируется на принципе "аппликации" (application), или "применения". Это означает, что &lambda;-функции не вызывают, а применяют (или, если хотите, прикладывают) к аргументу. Знаю, это звучит странновато для уха программистов из мира C, потому что там аргумент "прикладывают" к функции, но в математике договорились на таком определении. Поэтому запись вида:

<cpp>
f a
</cpp>

принято читать так: применение функции <code>f</code> к аргументу <code>a</code>.

Вот как это выглядит в Haskell:

<hs>
(\x -> x*x) 5
</hs>

Как видите, тут тоже прямое сходство с математической записью. Выражение в скобках - это уже знакомое нам &lambda;-выражение. Оно "порождает" &lambda;-функцию, которая сразу же применяется (прикладывается) к аргументу 5, результатом чего и явится значение 25.

Таким образом, можно сказать, что перед нами - вызов &lambda;-функции с аргументом 5, но учитывая математические корни языка Haskell, можно сказать, что перед нами - применение &lambda;-функции к аргументу 5.

<h3>Да, но какая же от всего этого польза?</h3>

Действительно, пора и к практике переходить.

В языке C принят стандартный "круг трёх шагов" по работе с функцией:

<ol>
  <li>объявление,</li>
  <li>определение,</li>
  <li>вызов.</li>
</ol>

И потому работа с нашей функцией возведения в квадрат, применительно к языку C, могла бы выглядеть так:

<cpp>
int f( int i ) {
    return i * i;
}

int main() {
    printf( "%d", f( 5 ) );
}
</cpp>

Мы подготовили нашу "глобальную подпрограмму", в которую чуть позже зайдём через вызов (фактически - через разыменование указателя <code>f</code>).

А вот как это выглядело бы на Haskell:

<hs>
main =
    putStrLn (show ((\x -> x * x) 5))
</hs>

Как видите, мы ничего не готовим заранее. Напротив, мы <em>создаём</em> функцию (или, если хотите, функциональный объект) локально и непосредственно перед использованием. Создаём - и сразу апплицируем его к аргументу 5.

Для большей простоты и похожести на нашу функцию мы можем написать и так:

<hs>
main =
    do putStrLn (show (f 5))
    where f = (\x -> x*x)
</hs>

Выражение

<hs>
    where f = (\x -> x*x)
</hs>

это не присваивание (напомню, в Haskell его нет), это как бы ассоциация. Мы вводим локальный псевдоним для &lambda;-функции и называем его <code>f</code>.

Вы можете спросить меня, мол, какова же реальная польза от &lambda;-функции, если у нас есть функция обыкновенная? Ведь мы могли бы написать и так:

<hs>
f :: Integer -> Integer
f x =
    x * x

main =
    putStrLn (show (f 5))
</hs>

Тут всё как обычно: мы определили функцию <code>f</code> заранее, а потом апплицировали её к аргументу 5.

Так вот одно из преимуществ &lambda;-функции как раз и заключается в её локальности. Зачем нам определять (подготавливать заранее) некую "глобальную подпрограмму", если мы можем создать и использовать её непосредственно в том месте, где она нужна? Очень часто в реальных программах случается такое, что функция определяется лишь для того, чтобы быть вызванной в одном-единственном месте. Ну и зачем же нам определяеть её "глобально"?

Анонимность &lambda;-функции также видится мне преимуществом, по крайней мере в ряде случаев. Если действие, совершаемое с помощью конкретной &lambda;-функции, тривиально (и может быть понято из её "тела", как в случае с функцией возведения в квадрат) - зачем же нам придумывать имя? Мы можем спокойно обойтись без него. Однако, в том случае, когда &lambda;-функция нужна нам во многих местах кода, мы можем, во избежание дубляжа, "определить" &lambda;-функцию глобально. Делается это в нашем случае так:

<hs>
f = \x -> x * x

main =
    do putStrLn (show ((f 5) + (f 6)))
</hs>

Как видите, мы "определили" нашу функцию глобально и ассоциировали её с выражением <code>f</code>. Теперь мы можем многократно использовать это выражение в коде, для апплицирования его к различным аргументам (в данном случае к 5 и к 6).

Ну вот, собственно, и всё. Конечно, это далеко не вся информация о &lambda;-функциях, но этого базиса нам пока достаточно. Продолжение следует...
