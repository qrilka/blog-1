---
layout: post
title: 'C++11, enum class: решаем проблемы перечислений'
created: 1316415478
categories:
- c++11
- enum class
---
<!--break-->
Перечисления (<strong>enum</strong>) используются в C++-коде достаточно часто. Оно и понятно: возможность ассоциировать некое значение с понятным именем в ряде случаев довольно ценна. Однако с использованием перечислений сопряжены некотрые (хорошо известные) проблемы. Нет, они не всегда приводят к ошибкам, и если всегда быть внимательным, то и вспоминать о них, об этих проблемах, не придётся. Однако программисты не всегда внимательны, поэтому нововведение в C++11, называемое классы-перечисления (<strong>enum class</strong>), является действительно ценным.

Предназначение класса-перечисления именно в том, чтобы избавиться от проблем классического enum. Мы будем вспоминать эти проблемы последовательно, и тут же анализировать то, что предлагает C++11.

Сегодня рассмотрим первую проблему - область видимости значений.

Итак:
<cpp>
enum error {
      file_not_found
    , cannot_open
    , invalid_coding
};

int main() {
    error e = file_not_found;
}
</cpp>

Как видим, конкретное значение <strong>file_not_found</strong> принадлежит внешнему по отношению к enum пространству имён. Значит, если <strong>enum error</strong> определён в глобальном пространстве имён, то и его значения будут глобальны. Это не очень хорошо, хотя бы только потому, что возможен конфликт между именами в разных enum:

<cpp>
enum error {
      file_not_found
    , cannot_open
    , invalid_coding
};

// Где-то в другом месте...
enum error2 {
	  file_not_found
	, cannot_open
	, invalid_coding
};
</cpp>

Компилятор ругнётся, и правильно сделает:
error: conflicting declaration ‘file_not_found’
error: ‘file_not_found’ has a previous declaration as ‘error file_not_found’

Класс-перечисление решает эту проблему.

<cpp>
enum class error {   // Мы просто добавили слово class после enum, только и всего.
    file_not_found
    , cannot_open
    , invalid_coding
};

int main() {
    error e = error::file_not_found;
}
</cpp>

Как видим, значение <strong>file_not_found</strong> теперь принадлежит области видимости <strong>error</strong>, и это гораздо логичнее.

Понятно, что конфликта имён уже нет:

<cpp>
int main() {
    error e   = error::file_not_found;
    error2 e2 = error2::file_not_found;
}
</cpp>

Подобное решение делает код безопаснее и яснее для восприятия.
