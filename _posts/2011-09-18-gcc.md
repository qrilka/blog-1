---
layout: post
title: 'GCC: два компилятора вместе'
created: 1316357692
categories:
- c++11
- gcc
---
<!--break-->
Причины, подвигшие меня к установке <strong>g++ 4.6.0</strong>, просты: поддержка C++0x. Данная версия вышла 25 марта (любопытное совпадение: именно в этот день Комитетом по стандартизации был принят FDIS), и именно этой версией поддерживается наибольшее число возможностей нового языка.

Но в моей системе (Debain Linux Squeeze), естественно, уже стоял компилятор версии 4.4.5. Значит, нужно ставить в параллель.<br/>
<h3>Что нам понадобится?</h3>

Собственно, сам компилятор. Напомню, что GCC - это семейство компиляторов для разных языков. Но нас интересует только С++, поэтому скачиваем следующие пакеты:

ftp://ftp.gnu.org/gnu/gcc/gcc-4.6.0/gcc-core-4.6.0.tar.bz2 - ядро компилятора.
ftp://ftp.gnu.org/gnu/gcc/gcc-4.6.0/gcc-g++-4.6.0.tar.bz2 - собственно g++.

Но это ещё не всё. Нам понадобятся также три служебные библиотеки - GMP, MPC и MPFR:

ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-4.3.2.tar.bz2
ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz
ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2<br/>
<h3>Подготовка пути</h3>

Кладём все архивы в некую папку, она будет корнем установки нового компилятора. В моей системе это /home/denis/Distros/GCC/. Этот путь будет использован в качестве установочного префикса при сборке. Для краткости далее будем именовать его <strong>INSTALL_PATH</strong>.<br/>
<h3>Подготовка компилятора</h3>

Распаковываем <strong>gcc-core-4.6.0.tar.bz2</strong> и получаем папку <strong>gcc-4.6.0</strong>. А вот теперь есть одна хитрость. Дело в том, что когда мы распакуем <strong>gcc-g++-4.6.0.tar.bz2</strong>, то получится такая же папка <strong>gcc-4.6.0</strong>. Поэтому я разношу их при распаковке в разные места.

Захожу в папку <strong>gcc-4.6.0</strong>, полученную при распаковке <strong>gcc-g++-4.6.0.tar.bz2</strong> и вижу там две папки: <strong>gcc</strong> и <strong>libstdc++-v3</strong>. Теперь:
<ol>
 <li>папку <strong>libstdc++-v3</strong> копирую в корень папки <strong>gcc-4.6.0</strong>, полученной при распаковке <strong>gcc-core-4.6.0.tar.bz2</strong>.</li>
 <li>в папке gcc берём папку cp и копируем её в подпапку gcc папки <strong>gcc-4.6.0</strong>, полученной при распаковке <strong>gcc-core-4.6.0.tar.bz2</strong>.</li>
</ol>
Итак, мы получили одну папку <strong>gcc-4.6.0</strong>, в которой есть всё необходимое для сборки. Та папка <strong>gcc-4.6.0</strong>, которая была получена их архива <strong>gcc-g++-4.6.0.tar.bz2</strong>, нам больше не нужна.<br/>
<h3>Сборка служебных библиотек</h3>

Теперь распаковываем архивы трёх вышеупомянутых служебных библиотек. Их необходимо собрать и установить <strong><em>перед</em></strong> сборкой компилятора.

Более того, важен порядок их сборки, поскольку они зависят друг от друга.

Первой собираем GMP. Не забываем указать упомянутый выше префикс установки:
<cpp>$ ./configure --prefix=INSTALL_PATH</cpp>
Потом make и make install.

Далее собираем MPFR. Указываем установочный префикс и путь к (уже) установленной GMP:
<cpp>$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH</cpp>
Потом make и make install.

Последней собираем MPC. Указываем установочный префикс, а также пути к (уже) установленным GMP и MPFR:
<cpp>$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH --with-mpfr=INSTALL_PATH</cpp>
Потом make и make install.

Итак, служебные библиотеки собраны.<br/>
<h3>Сборка компилятора</h3>

Указываем установочный префикс и пути к (уже) установленным служебным библиотекам:
<cpp>$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH --with-mpfr=INSTALL_PATH --with-mpc=INSTALL_PATH</cpp>

Далее make. Начинается компиляция компилятора (приколько звучит).<br/>
<h3>Подводный камень №1</h3>

Вы думаете, что всё скомпилируется и готово? Не тут-то было. Компиляция прервётся с ошибкой. А причина в том, что мы забыли передать путь к служебным библиотекам линковщику, а в процессе сборки они понадобятся. Поэтому пропишем путь INSTALL_PATH/lib в <strong>/etc/ld.so.conf</strong>. Не забываем выполнить магическое <strong>ldconfig</strong>.

После этого снова make. Компиляция продолжится.<br/>
<h3>Подводный камень №2</h3>

Ну теперь-то всё? Нет, не всё. Если у вас 64-разрядная система (как у меня), то компиляция снова прервётся. Причина в отсутствии файла <strong>/usr/include/gnu/stubs-32.h</strong>. Если вы посмотрите, то файл stubs-64.h имеется, а stubs-32.h отсутствует. Чтобы это исправить, необходимо установить пакет <strong>libc6-dev-i386</strong>. В репозитории Debian такой имеется. После этого требуемый файл появится.

После этого снова make. Компиляция продолжится.<br/>
<h3>Подводный камень №3</h3>

Итак, компиляция завершена. К слову сказать, займёт она довольно много времени. На моей системе с Corei3 2.4Ггц и 2 Гб DDR3 памяти компиляция забрала часа полтора.

После этого вы делаете make install. И в INSTALL_PATH появятся несколько дополнительных папок, такие как lib32, lib64, bin, libexec, share.

И вот вы, в предвкушении испытаний, пишете свой hello world и скармливаете его новому компилятору. Компиляция проходит успешно, только вот запустить программу не удастся. Причина проста: стандартная библиотека.

Проверим:
<pre>$ ldd my_program
    ...
    libstdc++.so.6 => /usr/lib/libstdc++.so.6  
    ...</pre>

Итак, причина в том, что стандартная библиотека С++ берётся из старого пути, из <strong>/usr/lib</strong>. Но ведь там лежит библиотека, используемая нашим "старым" компилятором (в моём случае g++ 4.4.5). А нам нужна новая библиотека, собранная с новым компилятором.

Решение простое: пропишем путь к новой стандартной библиотеке INSTALL_PATH/lib64 (для 64-разрядной системы) в <strong>/etc/ld.so.conf.d/libc.conf</strong>. Я у себя прописал этот путь первым по счёту в данном файле.

После этого снова компилируем программу, и проверяем вновь:
<pre>$ ldd my_program
    ...
    libstdc++.so.6 => INSTALL_PATH/lib64/libstdc++.so.6  
    ...</pre>

Теперь используется новая стандартная библиотека, как нам и нужно.<br/>
<h3>Завершение</h3>

Ну что ж, сборка и настройка завершена. В подтверждение этому попробуем скомпилировать программу с новейшими возможностями стандарта. В частности, проверим range for. Разумеется, необходимо также указать флаг <strong>-std=c++0x</strong>, всё-таки поддержка нового стандарта носит (формально) экспериментальный характер.

<cpp>
int main() {
    std::vector< int > v = { 1, 2, 3 };
    for ( auto i : v ) {
        std::cout << i << std::endl;
    }
}
</cpp>

Итак, как видите, всё работает. Теперь в нашей системе есть два компилятора, и мы можем продолжить наши эксперименты с новейшими возможностями C++0x.
