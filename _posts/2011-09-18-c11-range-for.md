---
layout: post
title: 'C++11: анализ range-for'
created: 1316357861
categories:
- !binary |-
  0Y3RhNGE0LXQutGC0LjQstC90L7RgdGC0Yw=
- range-for
- c++11
- auto
---
<!--break-->
Итак, сподобившись-таки поставить <strong>g++ 4.6.0</strong> (подробности <strong><a href="http://dshevchenko.biz/ru/content/gcc-два-компилятора-вместе">тут</a></strong>), я решил испытать новый <strong>range for</strong> цикл и проверить его эффективность.

Итак, имеем код:
<cpp>
int main() {
    std::vector< unsigned long int > v;
    for ( size_t i = 0; i < 10000000; ++i ) {
        v.push_back( i );
    }
    BOOST_ASSERT ( 10000000 == v.size() );
    
    // Начало временнОго замера 1.
    BOOST_FOREACH ( auto i, v ) {
        const unsigned long int ii = i; // Условная работа.
    }
    // Конец временнОго замера 1.

    // Начало временнОго замера 2.
    for ( auto it = v.begin(); it != v.end(); ++it ) {
        const unsigned long int ii = *it; // Условная работа.
    }
    // Конец временнОго замера 2.

    // Начало временнОго замера 3.
    for ( auto i : v ) {
        const unsigned long int ii = i; // Условная работа.
    }
    // Конец временнОго замера 3.
}
</cpp>
Итак, результаты замеров следующие (огрублённые):
<pre>
1. 390 мс
2. 200 мс
3. 140 мс
</pre>
Ну и как вам? Оказывается, C++0x предоставляет не только наиболее удобный цикл, но и наиболее эффективный.

Ну что ж, многообещающе...
