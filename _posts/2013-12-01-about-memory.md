---
layout: post
title: О памяти
category: articles
tags: [C++, C, Haskell]
comments: true
share: true
---

Мы знаем, что все сущности, которые мы так заботливо создали в процессе написания кода, при запуске процесса находят своё уютное место где-то в памяти (выделенной этому процессу операционной системой). И когда в 70-х годах прошлого века родился великий и могучий язык C, он предоставлял программисту прямой доступ к управлению этой самой памятью. Впрочем, справедливее будет сказать не "предоставлял", а "заставлял". Программист должен был решать, в какой памяти будет создана та или иная сущность. Программист должен был решать, когда создавать эту сущность и кто будет ответственен за её жизненный цикл. Программист должен был решать, когда и как этот ответственный должен уничтожить эту сущность. Программист должен помнить, что создать объект или массив объектов - это две большие разницы, как говорят в Одессе. И даже после всего этого программист (с той или иной частотой) получал прелестные ошибки типа segmentation fault, bus error или double free...

То есть, во-первых, программист должен был держать в голове кучу специфической информации, а во-вторых, эта информация не избавляла его от вышеупомянутых ошибок. Ну не верю я в то, что существовал хотя бы один программист на C, который ни разу не получал segmentation fault...

К чему я веду? К тому, что с тех славных времён минуло уже более трёх десятилетий. Почему же и сегодня многие из нас продолжают думать о памяти? Какая разница, что мы сидим на Core i7, а не на i386, если натыкаемся на те же самые грабли?

Несомненно, нововведения в языке C++ (если уж говорить именно о нём) облегчили задачу программисту. Облегчили, но вовсе не избавили его от упомянутых выше проблем. Но суть даже не в том, чтобы обсуждать сильные и слабые стороны какого-нибудь <code>std::shared_ptr</code>. Суть в том, что это ненормально, когда программист в 2013 году обязан думать о том же, о чём думал программист в 1979. Это неправильно.

Да, есть специфические области типа embedded development, в которых думать о памяти приходится всегда, но это уникальные и обособленные сегменты программирования. В остальных же случаях мы вынуждены признать: при всех вкусностях C++11, этот язык всё ещё остаётся стариком прошлого века в контексте управления памятью. Не потому что он делает это плохо, а потому, что он возлагает на меня как на разработчика *заботы* о памяти и *ответственность* за работу с ней.

Почему язык не может взять эти заботы и эту ответственность на себя? Ведь работа с памятью - это, по сути своей, "дела под капотом" языка. И я вовсе не горю желанием заглядывать под этот капот. Я хочу думать о решаемой мною задаче, а не о том, где, как и почему разместятся байты, соответствующие сущностям моего приложения.

Что же я предлагаю? <del>Всем срочно перейти на Haskell</del> Задуматься о перспективах. Мы видим, как меняется компьютерное железо. Но если софт не будет поспевать за железом, то он, этот софт, окажется слабым звеном в связке под названием "компьютер". Если есть языки программирования, в которых с программиста полностью снята ответственность за работу с памятью (как это и должно быть в 21 веке), то почему бы не... Ну вы поняли...
