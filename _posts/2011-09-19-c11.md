---
layout: post
title: 'C++11: хитрости со списком захвата'
created: 1316414937
categories:
- c++11
- !binary |-
  0LvRj9C80LHQtNCwLdGE0YPQvdC60YbQuNC4
---
<!--break-->
Итак, в списке захвата лямбда-выражения необходимо захватить значение, которое мы хотим использовать в теле лямбда-функции. В противном случае получаем ошибку компиляции.

Так-то оно так, но не всегда. :-)

Сразу пример:
{% highlight cpp %}
typedef std::vector< int > V;

int main() {
    V v{ 1, 2, 3 };
    const int i = 10;
    boost::range::for_each( v, []( const int elem ) {
                                   std::cout << elem + i << std::endl;
                               } );
}
{% endhighlight %}
Итак, значение **i** мы не захватили, однако будьте уверены - этот код компилируется. Более того, он корректно работает, и к каждому из элементов вектора честно прибавляется значение 10.

Обратите внимание, переменная **i** определена как **const**. В этом и ответ: мы можем использовать константное значение в теле лямбда-функции, не захватывая его в списке захвата.

Итак, то, что является константой времени компиляции, можно использовать без захвата.

Подтвердим наше предположение следующим примером:
{% highlight cpp %}
typedef std::vector< int > V;

enum { i = 10 };

int main() {
    V v{ 1, 2, 3 };
    boost::range::for_each( v, []( const int elem ) {
                                   std::cout << elem + i << std::endl;
                               } );
}
{% endhighlight %}
Итак, используем значение из **enum**, то есть константу времени компиляции. И опять, уверяю вас, код компилируется и работает правильно, хотя список захвата остаётся пустым.
