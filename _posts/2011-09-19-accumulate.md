---
layout: post
title: 'accumulate и строки: подсказка'
created: 1316416743
categories:
- c++
---
<!--break-->
Стандартный алгоритм std::accumulate весьма полезен, когда вам нужно получить сумму элементов контейнера. Если для типа элементов контейнера определён опрератор сложения operator+, тогда на выходе вы получаете желаемую сумму.

Однако данный алгоритм требует, чтобы вы указали некое инициализационное значение, к которому будет прибавлено всё остальное. Но часто мы хотим использовать пустое инициализационное значение, и это понятно.

Допустим, у нас есть вектор строк, и нам необходимо получить конкатенированную строку на выходе. Пишем:

<cpp>
std::vector< std::string > v{ "aaa", "bbb", "ccc" };
std::string sum_of_strings = boost::accumulate( v, "" );
</cpp>

По (распространённой) привычке мы задали пустыми кавычками пустую строку, чтобы на выходе получить только фактическую сумму строк в контейнере, без всяких инициализационных значений. И ждём, что у нас всё заработает. Ну-ну...

Вот определение этого алгоритма:

<cpp>
template <class InputIterator, class T>
T accumulate ( InputIterator first, InputIterator last, T init );
</cpp>

И что же мы задали (в примере выше) в качестве типа T? Правильно, const char*. А нам-то ведь нужна строка. Так что правильно написать так:

<cpp>
std::string sum_of_strings = boost::accumulate( v, std::string() );
</cpp>

Вот теперь всё ок.
