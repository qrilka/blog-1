---
layout: post
title: 'Haskell: о функциях высшего порядка'
category: articles
tags: [Haskell]
comments: true
share: true
---

Функции высшего порядка (higher-order functions) - очень важная и очень интересная особенность языка Haskell. Эта особенность основана на том постулате, что функции в Haskell - это *значения*. Знаю, это не так легко укладывается в голове, но такова особенность функционального программирования в целом: функции являются значениями (в широком смысле этого слова). Впрочем, если вы прочитали мою прошлую заметку о чистых функциях, вас это уже не должно удивлять, потому что вы уже знаете. что вызов чистой функции в конечном итоге порождает некоторое конечное выражение (являющееся итогом вычисления всех выражений в теле этой функции), которым компилятор заменяет место вызова.

А раз уж функции являются значениями, то их можно, во-первых, передавать другим функциям в качестве аргумента, а во-вторых, возвращать из других функций в качестве выходного значения. Так вот функция A, которая принимает некую функцию B в качестве аргумента и/или возвращает некую функцию C в качестве выходного значения, называется *функцией высшего порядка*.

<h3>А теперь начинаем удивляться...</h3>

Помните, когда я рассказывал вам о чистых функциях, было упомянуто, что такие функции могут принимать как один, так и множество аргументов. На самом деле, я обманул вас, ибо правда такова:

**Функции в Haskell всегда принимают только один аргумент. Ни больше, ни меньше.**

Но, простите, а как же мы смогли определить функции, принимающие два аргумента?? Отвечаю: это была хитрость. :)

Хитрость это называется "каррирование" (currying), иногда говорят "карринг". Слово это знаменитое, ибо оно происходит от имени **<a href="http://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>**. Да-да, этот тот самый американский математик, в честь которого назвали изучаемый нами язык.

Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую все эти аргументы по одному. Что за ерунда, спросите вы. Поясняю.

Определим функцию деления двух чисел:

{% highlight haskell %}
divide :: Double -> Double -> Double
divide arg1 arg2 = arg1 / arg2

main =
    putStrLn (show (divide 10.03 2.1))
{% endhighlight %}

Итак, мы определили функцию, принимающую два значения типа **<code>Double</code>** и возвращающую результат деления первого на второе. Всё предельно просто, не так ли? На самом деле, не так...

Если мы посмотрим "пот капот" вызова этой функции:

{% highlight haskell %}
divide 10.03 2.1
{% endhighlight %}

то узнаем, что вызов этой функции происходит *в два этапа*:

<ol>
  <li>Функция <code>divide</code> применяется к первому аргументу <code>10.03</code>, вычисляется и возвращает *функцию* типа <code>Double -> Double</code>.</li>
  <li>Эта возвращённая функция применяется ко второму аргументу <code>2.1</code>, вычисляется и возвращает конечное значение 4.776190476190476.</li>
</ol>

На самом деле мы могли бы более явно отразить эту "двуэтапность", переписав вызов так:

{% highlight haskell %}
(divide 10.03) 2.1
{% endhighlight %}

Понимаете, да? Функция всегда применяется только к одному аргументу: сначала к 10.03, а потом возвращённая первым вызовом функция применяется к 2.1.

Именно поэтому строка объявления такой функции содержит *две* стрелочки вместо одной:

{% highlight haskell %}
divide :: Double -> Double -> Double
{% endhighlight %}

Мы помним, что символ стрелочки говорит нам о функции. Так вот здесь мы видим *две* стрелочки именно потому, что вызов этой функции происходит в два этапа. И поэтому, строго говоря, неправильно читать это объявление так:

"Функция <code>divide</code> принимает два аргумента типа **<code>Double</code>** и возвращает значение типа **<code>Double</code>**."

Правильно читать так:

"Функция <code>divide</code> принимает первый аргумент типа **<code>Double</code>** и возвращает функцию типа **<code>Double -> Double</code>**, принимающую второй аргумент типа **<code>Double</code>** и возвращающую значение типа **<code>Double</code>**."

Более того, это правильное прочтение объявления можно было бы отразить явно и в самом объявлении! Вот так:

{% highlight haskell %}
divide :: Double -> (Double -> Double)
{% endhighlight %}

Теперь мы явно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа **<code>Double -> Double</code>**, а на втором этапе происходит уже вызов этой (возвращённой на первом этапе) функции.

По аналогии, если бы у нас была функция, принимающая три аргумента:

{% highlight haskell %}
total_sum :: Double -> Double -> Double -> Double
total_sum arg1 arg2 arg3 = arg1 + arg2 + arg3

main =
    putStrLn (show (total_sum 10.03 2.1 45.7))
{% endhighlight %}

то её вызов на самом деле проходил бы *в три этапа*, и чтобы явно отразить это, мы могли бы переписать её объявление так:

{% highlight haskell %}
total_sum :: Double -> (Double -> (Double -> Double))
{% endhighlight %}

а её вызов - так:

{% highlight haskell %}
((total_sum 10.03) 2.1) 45.7
{% endhighlight %}

А теперь нам нужно уточнить одну важную деталь.

<h3>Частичное применение функции</h3>

Вспомните, что я сказал о функции <code>divide</code>: её вызов происходит *в два этапа*. Так вот важно понимать, что функция <code>divide</code> вызывается *один* раз, а не два раза! Вызов один (то есть тело этой функции выполняется единократно), просто этот вызов разделён на два шага. А чтобы понять суть этих шагов, необходимо узнать об одной важной детали: частичное применение функции. Звучит страшновато, но суть очень проста.

Частичное применение (partial application) функции - это такой её вызов, когда ей на вход подаются не все аргументы, которые она ожидает. И здесь нам пригодятся уже известные нам **<a href="http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85">&lambda;-функции</a>**.

Представим себе, что наша функция <code>divide</code> была бы апплицирована (применена) не к двум, а только к одному аргументу. Тогда это выглядело бы так:

{% highlight haskell %}
main = 
    let temporary_function = divide 10.03 -- "запомнили" первый
    in 
    putStrLn (show (temporary_function 2.1)) -- получили второй!
{% endhighlight %}

Вот теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает вызов вида:

{% highlight haskell %}
(divide 10.03) 2.1
{% endhighlight %}

В результате первого вызова, когда мы применили функцию <code>divide</code> лишь к одному (первому) аргументу, мы ещё не можем получить результат деления, потому что второго-то аргумента мы функции ещё не дали! Вместо этого мы получили как бы временную (промежуточную) &lambda;-функцию, которую мы для наглядности ассоциировали с выражением <code>temporary_function</code>. Эта временная &lambda;-функция как бы запомнила значение первого аргумента, и когда мы применили её уже ко второму аргументу, то в результате мы уже получили итоговый результат деления.

По аналогии, вызов нашей функции <code>total_sum</code>, который, как мы помним, происходит в три этапа, можно разложить так:

{% highlight haskell %}
total_sum :: Double -> Double -> Double -> Double
total_sum arg1 arg2 arg3 = arg1 + arg2 + arg3

main =
    let first_function = total_sum 1.0 -- "запомнили" первый
        second_function = first_function 2.0 -- "запомнили" второй
    in
    putStrLn (show (second_function 3.0)) -- получили третий!
{% endhighlight %}

То есть в процессе вызова у нас появилось уже две промежуточные &lambda;-функции, каждая из которых принимала лишь один аргумент и как бы запоминала его. И только тогда, когда вторая промежуточная &lambda;-функция была апплицирована к третьему аргументу (который и оказался последним необходимым для нас), мы и получаем итоговую сумму.

Разумеется, на практике вводить такие промежуточные &lambda;-функции вам не придётся. Я лишь показал процесс каррирования на практике. Считайте, что мы просто заглянули "под капот" функции и увидели её внутреннюю "пошаговость".

<h3>"Ну хорошо, а зачем всё это нужно??"</h3>

Резонный вопрос. На самом деле, в подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении к аргументам *не нужно*. Главное преимущество такого подхода, при котором одна функция от нескольких аргументов раскладывается на цепочку функций от одного аргумента каждая, лежит в "академическом измерении": проводить формальные математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и выдаёт строго одно значение.

Но нас-то с вами, как программистов-практиков, гораздо больше интересует аспект практический, а не академический. И поэтому теперь мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).

Формально функции <code>divide</code> и <code>total_sum</code> являются ФВП, в силу тех самых промежуточных &lambda;-функций. Фактически, все функции, объявленные как принимающие более одного аргумента, являются ФВП. Но на самом деле все эти промежуточные &lambda;-функции - это всего лишь подкапотные дела, они скрыты от наших глаз, в то время как гораздо больший интерес представляют "настоящие" ФВП, которые характеризуются именно тем, что явно объявлены как принимающие на вход реальные функциональные значения и/или возвращающие реальные функциональные значения.

А чтобы разобраться в том, как всё это работает на практике, и понять реальную пользу от ФВП, давайте разберём небольшой пример.

{% highlight haskell %}
type Login = String
type Password = String
type AvatarURL = String
type UserId = Integer

user_info :: Login -> Password -> AvatarURL -> UserId -> String
user_info login password avatar_URL user_id =
    "Full info about user @" ++ (show user_id) ++ ":" ++
    "\n login: " ++ login ++
    "\n password: " ++ password ++
    "\n avatar URL: " ++ avatar_URL

type EmptyInfo = Login -> Password -> AvatarURL -> UserId -> String
type WithLogin = Password -> AvatarURL -> UserId -> String
type AndWithPassword = AvatarURL -> UserId -> String
type AndWithAvatarURL = UserId -> String

store_login_in :: EmptyInfo -> UserId -> WithLogin
store_login_in empty_info user_id =
    empty_info "denis"
    -- В реальности логин будет получен 
    -- в соответствии с переданным user_id

store_password_in :: WithLogin -> UserId -> AndWithPassword
store_password_in info_with_login user_id =
    info_with_login "123456789abc"
    -- В реальности пароль будет получен 
    -- в соответствии с переданным user_id

store_avatar_URL_in :: AndWithPassword -> UserId -> AndWithAvatarURL
store_avatar_URL_in info_with_password user_id =
    info_with_password "http://dshevchenko.biz/denis_avatar.png"
    -- В реальности URL будет получен 
    -- в соответствии с переданным user_id

main =
    let user_id = 1234
        info_with_login = store_login_in user_info 
                                         user_id
        info_with_password = store_password_in info_with_login 
                                               user_id
        info_with_avatar_URL = store_avatar_URL_in info_with_password 
                                                   user_id
        full_info_about_user = info_with_avatar_URL user_id
    in
    putStrLn full_info_about_user
{% endhighlight %}

Красиво, не так ли? Давайте разберём это хозяйство по косточкам...

Во-первых, новая для нас конструкция вида:

{% highlight haskell %}
type Login = String
{% endhighlight %}

Очевидно, вы уже догадались, что это всего лишь добавление псевдонима для (уже известного) типа. Теперь вместо типа **<code>String</code>** можно использовать идентификатор <code>Login</code>.

Далее мы определили простую функцию вида:

{% highlight haskell %}
user_info :: Login -> Password -> AvatarURL -> UserId -> String
{% endhighlight %}

Тут всё просто: функция <code>user_info</code> ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую результирующую строку.

А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется лишь некий идентификатор пользователя, а соответствующие этому идентификатору логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, откуда получить логин, пароль и путь к аватару соответственно. Причём каждая из этих трёх функций является ФВП!

Обратите внимание на следующие псевдонимы:

{% highlight haskell %}
type EmptyInfo = Login -> Password -> AvatarURL -> UserId -> String
type WithLogin = Password -> AvatarURL -> UserId -> String
type AndWithPassword = AvatarURL -> UserId -> String
type AndWithAvatarURL = UserId -> String
{% endhighlight %}

Каждый из них вводит упрощающее имя для функционального типа, образованного от типа функции <code>user_info</code>. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Чтобы было понятнее, изобразим это с соответствующими сдвигами:

{% highlight haskell %}
EmptyInfo = Login -> Password -> AvatarURL -> UserId -> String
WithLogin =          Password -> AvatarURL -> UserId -> String
AndWithPassword =                AvatarURL -> UserId -> String
AndWithAvatarURL =                            UserId -> String
{% endhighlight %}

Каждый из этих псевдонимов задаёт сигнатуру для (очередной) промежуточной &lambda;-функции, и нужно это, как вы уже догадались, для упомянутого выше частичного применения функции <code>user_info</code>.

Рассмотрим первый вызов:

{% highlight haskell %}
        info_with_login = store_login_in user_info 
                                         user_id
{% endhighlight %}

Здесь мы передаём функцию <code>user_info</code> в качестве первого аргумента функции <code>store_login_in</code>, внутри которой мы апплицируем переданную функцию <code>user_info</code> к единственному аргументу, а именно к логину (потому что функция <code>store_login_in</code> знает только о том, откуда и как получить логин). Соответственно, на выходе из функции <code>store_login_in</code> мы получаем первую промежуточную &lambda;-функцию, в которой мы как бы сохранили (store) значение логина (именно поэтому сигнатура этой &lambda;-функции названа <code>WithLogin</code>).

Далее следует вызов:

{% highlight haskell %}
        info_with_password = store_password_in info_with_login 
                                               user_id
{% endhighlight %}

Здесь мы передаём нашу промежуточную &lambda;-функцию (в которой мы как бы сохранили значение логина) в качестве первого аргумента функции <code>store_password_in</code>. Эта функция, в свою очередь, апплицирует переданную ей &lambda;-функцию к единственному аргументу, а именно к паролю (ибо функция <code>store_password_in</code>, как вы уже поняли, умеет доставать только пароль). Таким образом, на выходе из функции <code>store_password_in</code> мы имеем вторую промежуточную &lambda;-функцию, в которой как бы сохранены уже два значения (полученный на предыдущем вызове логин и на этом вызове - пароль), именно поэтому сигнатура этой &lambda;-функции носит имя <code>AndWithPassword</code>.

То же самое справедливо и для следующего вызова:

{% highlight haskell %}
        info_with_avatar_URL = store_avatar_URL_in info_with_password 
                                                   user_id
{% endhighlight %}

На выходе из функции <code>store_avatar_URL_in</code> мы получаем третью &lambda;-функцию, в которой как бы сохранены уже три значения: логин, пароль и путь к аватару.

В итоге всё завершается апплицированием этой третьей &lambda;-функции к последнему нужному аргументу, а именно к идентификатору пользователя:

{% highlight haskell %}
        full_info_about_user = info_with_avatar_URL user_id
{% endhighlight %}

Именно здесь и происходит наконец "полноценный" вызов функции <code>user_info</code>, в результате которого мы получаем и выводим на экран результирующую строку следующего вида:

<bash>
Full info about user @1234:
 login: denis
 password: 123456789abc
 avatar URL: http://dshevchenko.biz/denis_avatar.png
</bash>

Таким образом, функция <code>user_info</code> была частично апплицирована три раза (каждый раз получая очередной аргумент), и лишь на четвёртый она получила все четыре необходимых ей аргумента. Мы можем сравнить это с конвейерной цепочкой, которую прошла данная функция: на каждом шаге она получала очередной аргумент.

Итак, перед нами - живая демонстрация реальной пользы ФВП. Да, признаю, этот пример можно было бы упростить (в данном конкретном случае можно было обойтись без частичного применения), но цель была не в том, чтобы дать на 100% оптимальное решение, а в том чтобы продемонстрировать упомянутую выше теорию на практическом примере. И как вы смогли убедиться, эта теория лишь поначалу казалось нам страшноватой, в реальности же она достаточно проста.
