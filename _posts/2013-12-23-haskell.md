---
layout: post
title: 'Haskell: о функциях'
created: 1387792902
categories:
- haskell
---
<!--break-->
Если вы помните <strong><a href="http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85">заметку о лямбда-функциях</a></strong>, математическое определение функции очень простое:

<strong>Функция - это описание зависимости чего-то от чего-то.</strong>

Так вот чистые функции в языке Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, <em>как</em> входное выражение (или совокупность таковых) определяет выходное выражение. Именно поэтому они не имеют побочных эффектов, и если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз получим один и тот же ответ.

А теперь за дело.

<h3>Объявляем</h3>

Начинается всё с объявления функции:

<hs>
simple_sum :: Int -> Int
</hs>

Перед нами - объявление выражения. До символа <code>::</code> указывается имя выражения, а после - тип выражения. 

<hs>
simple_sum :: Int -> Int
|        |    |        |
   имя           тип
</hs>

Итак, перед нами выражение с именем <code>simple_sum</code>, имеющее тип функции. Пусть вас не смущают эти слова: в Haskell функция - это тоже тип. Но откуда же мы знаем, что тип этого выражения представляет собой именно функцию? Давайте рассмотрим описание типа подробнее:

<hs>
Int -> Int
</hs>

Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами функция. Слева от неё указан тип единственного аргумента функции (в данном случае это стандартный тип <strong><code>Int</code></strong>), а справа от неё - тип выходного выражения (тот же <strong><code>Int</code></strong>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации через функцию - от входа к выходу, слева направо.

В силу того, что чистая функция в Haskell является математической, невозможно написать аналоги вот таких C-шных функций:

<cpp>
void f();
int f();
void f( int i );
</cpp>

Чистая функция в Haskell обязана иметь входной аргумент (хотя бы один) и выходное значение. Почему? Потому что это отражает суть математической функции: что-то <em>обязательно</em> подаём на вход и что-то <em>обязательно</em> получаем на выходе.

Кстати, о количестве аргументнов. Разумеется, чистая функция может принимать несколько аргументов. В этом случае её тип будет выглядеть так:

<hs>
Int -> Int -> Int
</hs>

Я понимаю, выглядит чуток странно, но читать это очень просто: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:

<hs>
Int -> Int -> Int -> Int
типы аргументов  |  | тип того, что будет на выходе 
</hs>

Итак, с объявлением разобрались. Идём дальше.

<h3>Определяем</h3>

Теперь функцию нужно определить. Кстати, определить нужно <em>обязательно</em>. Известно, что в том же C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда нигде не вызывается). В Haskell более строгий подход: если объявил - будь добр и определить, в противном случае компилятор выскажет своё недовольство.

Итак, сразу после объявления пишем тело функции:

<hs>
simple_sum :: Int -> Int
simple_sum value = value + value
</hs>

Рассмотрим его подробнее:

<hs>
simple_sum value = value + value
</hs>

Здесь ментальным разделителем является знак равенства. Напоминаю, что в Haskell нет оператора присваивания, поэтому знак равенства здесь - это именно <em>знак равенства</em>, как в математике. Скелет данного выражения можно представить так:

<hs>
name arguments = body_expression
</hs>

Здесь:

<ul>
  <li><code>name</code> - имя функции.</li>
  <li><code>arguments</code> - список имён аргументов (именно имён, а не их типов).</li>
  <li><code>body_expression</code> - тело функции.</li>
</ul>

В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется чрезвычайно простое тело, в котором мы просто-напросто складываем аргумент с самим собой.

<h3>Вызываем</h3>

Теперь нашу функцию можно вызывать с аргументом 4 (или, как привычно говорить в мире ФП, апплицировать функцию к аргументу 4):

<hs>
main = putStrLn (show (simple_sum 4))
</hs>

В ответ получаем ожидаемое значение:

<bash>
8
</bash>

<h3>А теперь подробнее...</h3>

Естественно, всё вышесказанное - это лишь самые азы. Теперь же необходимо уточнить некоторые детали.

<h4>Выход из функции</h4>

В C++, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле написать инструкцию <strong><code>return</code></strong>. Это - точка выхода из тела функции. Кроме того, мы знаем, что точек выхода из тела функции может быть сколько угодно. В Haskell же всё обстоит иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <strong><code>return</code></strong> в Haskell нету.

Да, я понимаю, это удивляет. Мол, а как же нам быть, если мы хотим указать точку выхода явно? Но если мы вспомним математическую природу чистой функции, то поймём, что иначе быть не может. Ведь чистая функция представляет собой описание зависимости выходного выражения от совокупности входных выражений, поэтому её тело представляет собой совокупность выражений, которые вычисляются (в некотором порядке) и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться точкой выхода из функции.

Чтобы стало понятнее, приведу пример:

<hs>
indicate :: String -> String
indicate address = 
    if address == "127.0.0.1"
    then
        "localhost"
    else 
        address
</hs>

Эта функция принимает единственный аргумент типа <strong><code>String</code></strong>, соответствующий некоему IP-адресу. В теле функции происходит проверка аргумента на равенство адресу "127.0.0.1", в результате мы оказываемся в одной из двух логических ветвей. Если бы это была функция на C++, это выглядело бы примерно так:

<cpp>
std::string indicate( const std::string& address ) {
    if( address == "127.0.0.1" ) {
        return "localhost";
    } else {
        return address;
    }
}
</cpp>

Обратите внимание, что мы явно указали две точки выхода из функции. Но в Haskell это не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, оно и будет возвращено.

А чтобы стало совсем понятно, перепишем тело этой функции для того, чтобы избавиться от выражения <strong><code>if then else</code></strong>:

<hs>
indicate :: String -> String
indicate "127.0.0.1" = "localhost"
indicate address = address
</hs>

Мы вводим вместо одного тела два, для каждого из которых мы определяем свою зависимость. Мы как бы говорим: "Если входной аргумент будет равен "127.0.0.1", то пусть возвращаемым функцией значением будет строка "localhost", если же аргумент будет какой-либо другой, то пусть возвращаемым функцией значением будет сам этот аргумент." Следовательно, когда компилятор увидит вызов этой функции в коде, он просто <em>подставит</em> на место этого вызова соответствующее выражение: либо строку "localhost", либо фактически переданный аргумент.

Теперь всё встало на свои места: явно определять точку выхода из чистой функции в Haskell не нужно потому, что конечное выражение в теле этой функции просто заменит собой вызов функции. То есть если написано так:

<hs>
main = putStrLn (indicate "127.0.0.1")
</hs>

то это то же самое, что было бы написано так:

<hs>
main = putStrLn "localhost"
</hs>

потому что компилятор, вычислив внутренности функции, просто заменит место вызова конечным (итоговым) выражением.

<h4>Локальные выражения</h4>

Очень полезно бывает ввести некое локальное значение в теле функции, например, для избавления от дубляжа кода или от магических чисел. Например, у нас есть такая функция:

<hs>
prepare_length :: Double -> Double
prepare_length line = 
    line * 0.4959
</hs>

Итак, мы готовим длину некой линии путём умножения её первоначальной длины на поправочный коэффициент. Но перед нами - магическое число, а это очень плохо. Добавлять комментарий - это не лучшее решение. Поэтому добавим локальное поясняющее выражение:

<hs>
prepare_length :: Double -> Double
prepare_length line = 
    line * coefficient
    where coefficient = 0.4959
</hs>

Красиво, не так ли? Ключевое слово <strong><code>where</code></strong> вводит локальное выражение, которое можно использовать в теле функции. Разумеется, локальных выражений может быть несколько:

<hs>
prepare_length :: Double -> Double
prepare_length line = 
    line * coefficient - correction
    where coefficient = 0.4959
          correction = 0.0012
</hs>

Есть ещё один способ ввести локальное вспомогательное выражение, с помощью ключевого слова <strong><code>let</code></strong>. На примере нашей последней функции это выглядит так:

<hs>
prepare_length :: Double -> Double
prepare_length line = 
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction
</hs>

Общая модель такая: <strong><code>let</code></strong> <code>bindings</code> <strong><code>in</code></strong> <code>expression</code>.

Но у вас, очевидно, возник вопрос, в чём же разница между <strong><code>where</code></strong> и <strong><code>let</code></strong>?

Во-первых, выражение <strong><code>where</code></strong> может быть только одно и только в конце тела функции, в то время как выражение <strong><code>let</code></strong> может присутствовать многократно и в любой части тела функции.

Во-вторых, выражение, введённое ключевым словом <strong><code>where</code></strong>, всегда видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <strong><code>let</code></strong>, может быть "супер-локальным". Например:

<hs>
prepare_length :: Double -> Double
prepare_length line = 
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction - (let s = 10.9 in s + 1) - s
</hs>

Понимаю, пример несколько надуманный, но всё-таки... Здесь мы ввели выражение с именем <code>s</code>, которое действует только внутри круглых скобок. Именно поэтому пример этот не скомпилируется, ведь второе выражение <code>s</code> находится уже не в скобках, и поэтому компилятор вполне справедливо возмутится:

<bash>
[2 of 2] Compiling Main             ( src/main.hs, dist/build/Haskell/Haskell-tmp/Main.o )

src/main.hs:43:61: Not in scope: `s'
</bash>

<h4>Про объявление</h4>

Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Отвечаю: можно, но не рекомендуется.

Общепринятой практикой является объявлять функцию и тут же определять её. И несмотря на то, что мы <em>можем</em> написать так:

<hs>
prepare_length line = 
    let coefficient = 12.4959
    in
    line * coefficient
</hs>

делать так не рекомендуется, поскольку определение функции становится как бы беднее, ведь сигнатура типов аргументов и возвращаемого выражения помогает лучше понять функцию.

К тому же в случае отсутствия объявления тип аргумента <code>line</code> становится неопределённым, и поэтому строгость проверки этого самого типа (на стадии компиляции) снизится. Если вы делаете это <em>сознательно</em> - три раза подумайте. Во всех же остальных случаях -  объявляйте.

<h4>Вот и всё?</h4>

Конечно, это далеко не всё, что можно сказать о чистых функциях, но этот базис достаточен для того, чтобы понять суть чистых функций и то, как их можно использовать в своём коде. Продолжение следует...
