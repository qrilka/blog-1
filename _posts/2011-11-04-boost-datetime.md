---
layout: post
title: 'Boost.DateTime: логический баг...'
created: 1320418150
categories:
- boost
---
<!--break-->
В нашем проекте мы столкнулись с проблемой, когда в объекте <strong>boost::posix_time::ptime</strong> в определённой ситуации появлялся мусор. Я разобрался, и вот что обнаружил.

Итак, простой пример:
<cpp>
int main() {
    using namespace boost::posix_time;
    ptime tm( time_from_string( "2011-01-01 00:00:00" ) );
    std::cout << tm << std::endl;
}
</cpp>

Вывод:
<pre>
2011-Jan-01 00:00:00
</pre>

Всё нормально. Но что будет, если мы не зададим время <em>явно</em>?
<cpp>
int main() {
    using namespace boost::posix_time;
    ptime tm( time_from_string( "2011-01-01" ) );
    std::cout << tm << std::endl;
}
</cpp>

На моём компьютере вывод оказался таким:
<pre>
2011-Mar-25 19:01:01
</pre>

Э-э... В высшей степени странный результат... Оказывается, время задавать <em>необходимо</em>. Но пусть бы тогда библиотека хоть исключение выкидывала, это по крайней мере заметно. А тут молча имеем какой-то мусор. 

Более того, тот же казус имеем и с другим способом:
<cpp>
int main() {
    using namespace boost::posix_time;
    ptime tm( from_iso_string( "20110101T000000" ) );
    std::cout << tm << std::endl;
}
</cpp>

Вывод:
<pre>
2011-Jan-01 00:00:00
</pre>

Опять-таки всё в порядке. Но если без времени:
<cpp>
int main() {
    using namespace boost::posix_time;
    ptime tm( from_iso_string( "20110101" ) );
    std::cout << tm << std::endl;
}
</cpp>
то вывод получаем не менее странный:
<pre>
2011-Jan-01 20:11:01.100000
</pre>

Значит, и тут время необходимо задавать. Но и тут никакого исключения, а лишь молчаливый мусор... Причём ошибки ISO-формата тут нет, 20110101 - это нормальная дата в соответствии с ISO 8601.

По моему убеждению, здесь имеет место логическая ошибка. Ведь если мы задали лишь дату (то есть конкретные сутки конкретного месяца конкретного года), но не указали время, то вполне логично предположить, что мы имели в виду <em><ins>начало</ins></em> этих суток, то есть 00:00:00. Поэтому в случае <em>отсутствия</em> времени никакого исключения быть, по-хорошему, не должно, а вместо него должен подставляться момент начала суток. Так почему же этого не происходит?

А всё просто. Дело в том, что в реализациях функций <strong>time_from_string()</strong> и <strong>from_iso_string()</strong> предполагается, что разделитель (в первом случае - пробел, а во втором случае - буква T) даты и времени присутствует <em>всегда</em>. И поэтому никакой проверки наличия этого разделителя не производится. Жаль.

Так что, друзья, знайте об этом баге и будьте внимательны.
