---
layout: post
title: 'while-цикл: проще некуда'
created: 1328194949
categories:
- !binary |-
  0JvQuNGC0LXRgNCw0YLRg9GA0L3QvtC1INC/0YDQvtCz0YDQsNC80LzQuNGA
  0L7QstCw0L3QuNC1
---
Допустим, мы видим такое письмо:
<cpp>
while( not_all( small_messages ).was_sended() ) {
    next_from( small_messages ) >> port;
}
</cpp>
Итак, одного взгляда достаточно, чтобы понять: здесь осуществляется поочерёдная отправка малых сообщений в порт до тех пор, пока оные имеются. Опустим детали о типе порта и формате сообщений, сейчас это не важно. Важно то, что такое письмо понятно любому. Сразу. Без пояснений.

Впрочем, давайте разберёмся, стоит ли игра свеч. Допустим, <strong>small_messages</strong> - это контейнер типа std::queue, и мы, запихнув в него N-ное число сообщений, теперь циклически вытаскиваем их по одному. Но разве в этом случае не проще ли было написать так:
<cpp>
while( !small_messages.empty() ) {
    small_messages.front() >> port;
    small_messages.pop();
}
</cpp>
Да, проще. Написать проще. Воспринять - чуть сложнее.

О-о, я уже слышу возгласы: "Да ты что, Денис, с ума сошёл? Да в таком элементарном цикле даже новичок разберётся!" Да, вы правы, разобраться в таком цикле <em>несложно</em>. Однако разобраться в моём варианте <em>проще</em>. <em>Объективно проще</em>.

Поясню. Взглянем на первую строку:
<cpp>
while( !small_messages.empty() )
</cpp>
О чём говорит нам эта строка? "До тех пор, пока контейнер сообщений не пуст..." И что? К сожалению, в этой строке нет никакого намёка на то, <em>что же</em> происходит до тех пор, пока контейнер сообщений не пуст. Однако если мы взглянем на предложенный мною вариант:
<cpp>
while( not_all( small_messages ).was_sended() )
</cpp>
то сразу же прочтём: "До тех пор, пока не все сообщения отправлены..." Ага, раз не все отправлены - значит, в цикле продолжится отправка. Предельно понятно, причём сразу.

Реализация "литературных элементов" предельно проста:
<cpp>
struct not_all {
    explicit not_all( messages const& a_messages ) :
            messages_for_sending( a_messages ) {}
private:
    messages const& messages_for_sending;
public:
    bool was_sended() const {
        return !messages_for_sending.empty();
    }
};

inline message next_from( messages& a_messages ) {
    auto const next_message( a_messages.front() );
    a_messages.pop();
    return next_message;
}
</cpp>
