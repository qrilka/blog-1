---
layout: post
title: Пользователям BOOST_FOREACH, важно...
created: 1316355985
categories:
- boost
---
<!--break-->
При переборе контейнера возвращается ссылка на текущий элемент. Но что происходит потом? 
Имеем код...
{% highlight cpp %}
class A {
public:
    A() { /* */ }
    A( const A& ) { /* Копирование может быть дорогостоящим... */ }
private:
    // Нечто важное...
public:
    void set_some_value(); // Важная операция!
    // ...
};

// Можно и простой STL-контейнер...
boost::ptr_vector< A > va;       // При переборе возвращает ссылку на хранимый объект.
va.push_back( new A() ); // A0
// ...
va.push_back( new A() ); // An

BOOST_FOREACH ( A a, va ) {
    a.set_some_value(); // Изменяем содержимое, но - вот незадача! - содержимое временной копии!
    // или...
    &a; // Что-то делаем с адресом, но с адресом временной копии!
}
{% endhighlight %}
Итак, казус. Мы хотим работать не с копиями (и тем более не с их адресами), а с самими объектами. Решение простое:
{% highlight cpp %}
BOOST_FOREACH ( A& a, va ) {   // Работаем со ссылкой, никакой временной копии.
    a.set_some_value(); // Ура, изменяем содержимое объекта!
    // или...
    &a; // Что-то делаем с адресом объекта, всё в порядке!
}
{% endhighlight %}
В этом случае мы убиваем двух зайцев. Во-первых, работаем не с временными копиями, а с самими объектами (или их адресами, что иногда бывает нужно), а во-вторых, не допускаем копирования на каждой итерации, потому что здесь имеет место присваивание возвращённой разыменованным итератором ссылки другой ссылке, и копирующий конструктор класса A не будет вызываться.

Кстати, последний довод не такой уж и пустяковый, особенно если представит ситуацию, когда в копирующем конструкторе выделяется динамическая память и количество элементов в контейнере va измеряется несколькими миллионами. :)

Любители оптимизации скажут мне: "Не валяй дурака, если нужна скорость - используй индексный перебор!" Верно, использование итераторов снижает скорость перебора (в ряде случаев это недопустимо). Однако в абсолютно подавляющем большинстве случаев итераторный перебор предпочтительнее, а следовательно, допустимо использовать (ещё более) удобный BOOST_FOREACH.

И напоследок. Нельзя изменять размер контейнера в процессе перебора. Впрочем, данное требование выглядит, как мне кажется, в высшей степени логичным. :)

Подробнее о BOOST_FOREACH читайте **<a href="http://www.boost.org/doc/libs/1_40_0/doc/html/foreach.html">здесь</a>**.
