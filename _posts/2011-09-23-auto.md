---
layout: post
title: 'auto и обобщённая инициализация: проблема?'
created: 1316764348
categories:
- !binary |-
  0LjQvdC40YbQuNCw0LvQuNC30LDRhtC40Y8=
- c++11
- auto
---
<!--break-->
В общем, там описана "типа проблема".

Итак:
{% highlight cpp %}
int main() {
    auto i{10};
    std::cout << i << std::endl;
}
{% endhighlight %}

Такой код не скомпилируется. Ошибка: no match for ‘operator<<’ in ‘std::cout << i’.

Э-э... Как это "нет оператора"? С каких это пор целочисленное значение в поток вывода запихнуть нельзя?!

Проблемы тут на самом деле никакой нет, программа сделала именно то, что мы ей сказали сделать.

Когда мы пишем:
{% highlight cpp %}
    auto i{10};
{% endhighlight %}
на стадии компиляции тип i определяется по типу правого значения. Так ведь справа-то у нас стоит не целочисленное значение, а {10}. Это - так называемый "список инициализации", один из стандартных (в C++11) типов.

Таким образом, i - это список инициализации, содержащий одно целочисленное значение 10. И вот этот список инициализации мы пытаемся вывести в std::cout. Ага, щаз!

Вывод прост: обобщённая инициализация с фигурными скобками чрезвычайно полезна, но она должна использоваться разумно. Её не нужно пихать везде и всюду. Понятно, что автор вышеприведённого примера имел в виду целочисленное значение. Это можно было написать так:
{% highlight cpp %}
int main() {
    auto i(10);
    std::cout << i << std::endl;
}
{% endhighlight %}или так:
{% highlight cpp %}
int main() {
    auto i = 10;
    std::cout << i << std::endl;
}
{% endhighlight %}и никаких проблем.
