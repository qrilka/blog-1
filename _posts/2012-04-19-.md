---
layout: post
title: К вопросу о математических функциях...
created: 1334815985
categories:
- !binary |-
  0KTRg9C90LrRhtC40L7QvdCw0LvRjNC90L7QtSDQv9GA0L7Qs9GA0LDQvNC8
  0LjRgNC+0LLQsNC90LjQtQ==
---
Продолжая своё изучение фукционального программирования, я неожиданно для себя самого осознал, что чистый функтор/функция, <ins>отражающий математическую модель</ins>, является наиболее простым решением.

Известно, что <em>"математическое понятие функции выражает интуитивное представление о том, как одна величина полностью определяет значение другой величины."</em> Пример:
<cpp>
struct square {
    int operator()( int const i ) const {
        return i * i;
    }
};
</cpp>Итак, вот простейший случай чистого функтора, отражающего математическую модель: результат использования этого функтора будет зависеть только от входного значения. Всегда.

И вот я подумал: а ведь это же чрезвычайно удобно! Если результат вызова функции полностью определён входными значениями, то:
<ol>
  <li>при отладке программы такую функцию легко убрать (заменив значением-заглушкой), и это никак не отразиться на остальной программе,</li>
  <li>тело такой функции легко изучать, поскольку оное изолировано от окружающего мира в силу отсутствия побочных эффектов и каких-либо косвенных связей,</li>
  <li>в такой функции легче искать (и труднее допустить) ошибки.</li>
</ol>

Поэтому чем больше подобных функторов/функций будет в программе, тем легче оная станет.

Ну вот, скажем, такой пример:
<cpp>
struct storage {
    storage() :
            m_capacity( 0 ) {
        obtain_capacity();
    }
private:
    size_t m_capacity;
private:
    void obtain_capacity() {
        size_t obtained_capacity = 0;
        // Получаем откуда-то извне ёмкость...
        m_capacity = obtained_capacity;
    }
};
</cpp>Итак, вот нам канонический побочный эффект: функция внутри себя изменяет то, что находится вне её. Если же подобных функций десять, или тридцать, то отслеживание побочных эффектов ощутимо усложняется. Горький опыт ловли багов убедителен...

А что если написать так:
<cpp>
struct storage {
    storage() :
            m_capacity( obtain_capacity() ) {}
private:
    size_t m_capacity;
private:
    size_t obtain_capacity() const {
        size_t obtained_capacity = 0;
        // Получаем откуда-то извне ёмкость...
        return obtained_capacity;
    }
};
</cpp>Смотрите, мы изолировали функцию obtain_capacity от этого побочного эффекта. И это упростило функцию (а чаще всего это позволит нам вообще вынести её в отдельный чистый функтор).

Вот из таких мелочей и состоит простота...
