---
layout: post
title: 'C++11: делегирующий конструктор'
category: articles
tags: [C++]
comments: true
share: true
---
Не так давно открыл для себя эту маленькую, но полезную возможность. Слышал о ней давно, но потом забыл, а тут вдруг неожиданно вспомнил и решил применить в своём коде.

Итак, есть у нас класс:
{% highlight cpp %}
class check {
public:
    explicit check( std::string const& path ) :
              a_path( path )
            , /* А тут инициализация других членов-данных...
               */ {}
    explicit check( QString const& path ) :
              a_path( path.toStdString() ) 
            , /* А тут инициализация других членов-данных...
               */ {}
private:
    std::string const a_path;
    // Другие члены-данные...
};
{% endhighlight %}Итак, для простоты использования конструктор перегружен двумя типами строк. Проблема такого подхода в том, что список инициализации других членов-данных нужно повторять дважды. Если же конструктор будет перегружен ещё одним типом - уже трижды повторять, и так далее. Некрасивое решение.

Более красивым решением являются делегирующие конструкторы.
{% highlight cpp %}
class check {
public:
    explicit check( std::string const& path ) :
              a_path( path )
            , /* А тут инициализация других членов-данных...
               */ {}
    explicit check( QString const& path ) :
            check( path.toStdString() ) {}
...
};
{% endhighlight %}Суть предельно ясна: один из конструкторов делегирует инициализацию другому, приводя тип своего аргумента к виду, понятному этому другому. В этом случае то, что происходит в списке инициализации, уже не повторяется.

Ещё один элегантный и простой способ борьбы с дубляжом кода - в нашу копилку.
