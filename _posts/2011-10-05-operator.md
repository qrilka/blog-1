---
layout: post
title: Функтор без operator()?
category: articles
tags: [C++]
comments: true
share: true
---
<!--break-->
Чтобы вы сказали, увидев такой код:

{% highlight cpp %}
    convert( text ).at <Base64>() >> std::cout;
{% endhighlight %}

Не важно, где создан и что из себя представляет объект **text**, не важно, где определён тип **Base64**. Важно другое: перед нами функтор без operator().

Классический вид функтора (или, как его ещё называют, функционального объекта) - класс с одним (или более) перегруженным operator(). Действительно, как же без этого оператора можно обойтись, если объект планируется "вызывать"? Причём неважно, будет ли функтор использоваться in-place, или же объект сначала будет создан, а потом где-то использован - обращение к функтору идёт через operator(). Это классика.

Но где есть классика, есть и модерн. Ведь **суть** функтора не в operator(), а в том, что он отражает действие подобно тому, как это делает функция. Вот наше действие: *конвертировать текст в Base64 и вывести результат в стандартный вывод*. Зачем же тут operator()?
