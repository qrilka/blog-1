---
layout: post
title: Функтор без operator()?
created: 1317822581
categories:
- !binary |-
  0JvQuNGC0LXRgNCw0YLRg9GA0L3QvtC1INC/0YDQvtCz0YDQsNC80LzQuNGA
  0L7QstCw0L3QuNC1
---
<!--break-->
Чтобы вы сказали, увидев такой код:

<cpp>
    convert( text ).at <Base64>() >> std::cout;
</cpp>

Не важно, где создан и что из себя представляет объект <strong>text</strong>, не важно, где определён тип <strong>Base64</strong>. Важно другое: перед нами функтор без operator().

Классический вид функтора (или, как его ещё называют, функционального объекта) - класс с одним (или более) перегруженным operator(). Действительно, как же без этого оператора можно обойтись, если объект планируется "вызывать"? Причём неважно, будет ли функтор использоваться in-place, или же объект сначала будет создан, а потом где-то использован - обращение к функтору идёт через operator(). Это классика.

Но где есть классика, есть и модерн. Ведь <strong>суть</strong> функтора не в operator(), а в том, что он отражает действие подобно тому, как это делает функция. Вот наше действие: <em>конвертировать текст в Base64 и вывести результат в стандартный вывод</em>. Зачем же тут operator()?
