---
layout: post
title: 'Boost.Assign 2.0: упрощение или усложнение?'
created: 1316416047
categories:
- c++
- boost
---
<!--break-->
Ну, во-первых, если кому-то интересно взглянуть на документацию к этому хозяйству - прошу <a href="http://svn.boost.org/svn/boost/sandbox/assign_v2/libs/assign/v2/doc/html/index.html">**сюда**</a>.

А, во-вторых, давайте вспомним, зачему была нужна эта библиотека? Она нужна была для того, чтобы упростить жизнь программиста. И не просто упростить, но сделать это *быстро*.

Давайте взглянем на самый первый пример использования первой Assign (желающие ознакомиться лично - <a href="http://www.boost.org/doc/libs/1_46_1/libs/assign/doc/index.html">**сюда**</a>):

{% highlight cpp %}
vector<int> v; 
v += 1,2,3,4,5,6,7,8,9;

map<string,int> m; 
insert( m )( "Bar", 1 )( "Foo", 2 );
{% endhighlight %}

Согласитесь, что даже без чтения остальной документации *любой* программист, имеющий хоть какой-то опыт работы с vector и map, поймёт этот код. Знаете почему? Потому что этот код простой. Я подчёркиваю: он простой даже для новичка. 

Более того, этот новичок сможет начать использовать такую библиотеку *сразу же*, и ему не потребуется изучать всю документацию для этого. Это и есть то, что я называю: "библиотека, упрощающая жизнь программиста".

А теперь взглянем на самый первый пример использования Assign 2.0 (он **<a href="http://svn.boost.org/svn/boost/sandbox/assign_v2/libs/assign/v2/doc/html/index.html">тут</a>**):

{% highlight cpp %}
typedef std::map<std::string, int> map_; map_ cal;
typedef map_::value_type p_;

boost::for_each(
    cal | do_csv_put<2>( "jan", 31, "feb", 28, "mar", 31 ),
    std::cout
        << lambda::bind( &p_::first, lambda::_1 ) << ':'
        << lambda::bind( &p_::second, lambda:: _1 ) << ' '
); // prints jan:31 feb:28 mar:31
{% endhighlight %}

Э-э... Хм...  

Друзья, режьте меня на части, но я всё равно буду утверждать, что такой код отпугнёт новичка. Знаете почему? Потому что этот код сложный.

Вдумайтесь: это ведь самый первый и простейший пример, а-ля "Hello world". Человек, который не знает, что такое lambda::bind и не знакомый с концепцией адаптеров (отражённной здесь перегруженным operator|) увидит это и подумает: "Ёлки-палки, если это - простейший пример, то что же там дальше?! И это библиотека для упрощения работы с контейнерами?!" Получается, такому человеку придётся хотя бы поверхностно познакомиться с лямбда-выражениями (и с Boost.Lambda в частности) только лишь для того, чтобы понять первый пример!

Я понимаю, есть библиотеки, который трудно начать использовать *сразу*. Spirit, MPL, Proto и некоторые другие действительно требуют достаточно глубокой подготовки. Но эти библиотеки являются серьёзными инструментами, и они вовсе не предназначены для того, чтобы их начали использовать через пару минут после установки Boost. Понятно, что если человек собирается создавать собственный DSEL на основе Proto, то он должен обладать достаточно глубокими знаниями C++, и ему, разумеется, придётся изучить документацию к Proto весьма глубоко.

Однако такие библиотеки, как Assign, именно для того и предназначены, чтобы их можно было использовать *сразу*, и чтобы высокой квалификации для этого не требовалось. Это те библиотеки, с которых начнёт новичок и по которым этот новичок будет судить о Boost в целом. И вот представьте себе, как он читает аннотацию к Assign:

**Filling containers with constant or generated data has never been easier.**

Чего-чего? Никогда не было проще? Вы что, издеваетесь? Я вспоминаю себя при освоении Assign первой версии, и если бы мне *тогда* дали Assign 2.0, я бы ужаснулся.

По моему мнению, авторы Assign 2.0 пошли куда-то не туда. Библиотека, предназначенная, по сути, лишь для того, чтобы упростить вставку элементов в контейнер, обязана быть простой. В противном случае зачем она нужна?
