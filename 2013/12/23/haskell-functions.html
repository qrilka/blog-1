<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Haskell: о функциях</title>
        
        <link rel="stylesheet" type="text/css" href="../../../css/default.css" />
        <link rel="icon" type="image/x-icon" href="../../../images/favicon.ico" />

        <script src="https://apis.google.com/js/platform.js" async defer>
            {lang: 'ru'}
        </script>
    </head>
    <body>
        <div id="wrapper">
        <div id="wrapper_2">
        
        <div id="header">
            <div id="logo">
                <a href="http://blog.dshevchenko.biz" title="Домой">Д. Шевченко</a><span class="logo-note">Программист, исследователь, писатель</span>
            </div>
            <div id="navigation">
                <a href="http://dshevchenko.biz" title="К корневому сайту"><span id="root_link">cd /</span></a>
                <a href="http://blog.dshevchenko.biz/archive.html">АРХИВ</a>
                <a href="http://blog.dshevchenko.biz/tags.html">ТЕМЫ</a>
                <a href="http://blog.dshevchenko.biz/feed.xml">RSS</a>
            </div>
        </div>

        <div id="content">
            <h1>Haskell: о функциях</h1>

            <div class="info">
    (2013, 12, 23)
</div>

<div id="tags_of_post">
    <a href="../../../tags/Haskell.html">Haskell</a>
</div>

<div style="padding-top: 20px;"></div>

<p>Если вы помните <strong><a href="http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85">заметку о лямбда-функциях</a></strong>, математическое определение функции очень простое:</p>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>
<p>Так вот чистые функции в языке Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, <em>как</em> входное выражение (или совокупность таковых) определяет выходное выражение. Именно поэтому они не имеют побочных эффектов, и если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз получим один и тот же ответ.</p>
<p>А теперь за дело.</p>
<h3>
Объявляем
</h3>

<p>Начинается всё с объявления функции:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simple_sum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>Перед нами - объявление выражения. До символа <code>::</code> указывается имя выражения, а после - тип выражения.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simple_sum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">|</span>        <span class="fu">|</span>    <span class="fu">|</span>        <span class="fu">|</span>
   имя           тип</code></pre>
<p>Итак, перед нами выражение с именем <code>simple_sum</code>, имеющее тип функции. Пусть вас не смущают эти слова: в Haskell функция - это тоже тип. Но откуда же мы знаем, что тип этого выражения представляет собой именно функцию? Давайте рассмотрим описание типа подробнее:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами функция. Слева от неё указан тип единственного аргумента функции (в данном случае это стандартный тип <strong><code>Int</code></strong>), а справа от неё - тип выходного выражения (тот же <strong><code>Int</code></strong>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации через функцию - от входа к выходу, слева направо.</p>
<p>В силу того, что чистая функция в Haskell является математической, невозможно написать аналоги вот таких C-шных функций:</p>
<p>{% highlight cpp %} void f(); int f(); void f( int i ); ```</p>
<p>Чистая функция в Haskell обязана иметь входной аргумент (хотя бы один) и выходное значение. Почему? Потому что это отражает суть математической функции: что-то <em>обязательно</em> подаём на вход и что-то <em>обязательно</em> получаем на выходе.</p>
<p>Кстати, о количестве аргументнов. Разумеется, чистая функция может принимать несколько аргументов. В этом случае её тип будет выглядеть так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>Я понимаю, выглядит чуток странно, но читать это очень просто: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
типы аргументов  <span class="fu">|</span>  <span class="fu">|</span> тип того, что будет на выходе </code></pre>
<p>Итак, с объявлением разобрались. Идём дальше.</p>
<h3>
Определяем
</h3>

<p>Теперь функцию нужно определить. Кстати, определить нужно <em>обязательно</em>. Известно, что в том же C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда нигде не вызывается). В Haskell более строгий подход: если объявил - будь добр и определить, в противном случае компилятор выскажет своё недовольство.</p>
<p>Итак, сразу после объявления пишем тело функции:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simple_sum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
simple_sum value <span class="fu">=</span> value <span class="fu">+</span> value</code></pre>
<p>Рассмотрим его подробнее:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">simple_sum value <span class="fu">=</span> value <span class="fu">+</span> value</code></pre>
<p>Здесь ментальным разделителем является знак равенства. Напоминаю, что в Haskell нет оператора присваивания, поэтому знак равенства здесь - это именно <em>знак равенства</em>, как в математике. Скелет данного выражения можно представить так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">name arguments <span class="fu">=</span> body_expression</code></pre>
<p>Здесь:</p>
<ul>
  <li>
<code>name</code> - имя функции.
</li>
  <li>
<code>arguments</code> - список имён аргументов (именно имён, а не их типов).
</li>
  <li>
<code>body_expression</code> - тело функции.
</li>
</ul>

<p>В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется чрезвычайно простое тело, в котором мы просто-напросто складываем аргумент с самим собой.</p>
<h3>
Вызываем
</h3>

<p>Теперь нашу функцию можно вызывать с аргументом 4 (или, как привычно говорить в мире ФП, апплицировать функцию к аргументу 4):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (show (simple_sum <span class="dv">4</span>))</code></pre>
<p>В ответ получаем ожидаемое значение:</p>
<p><bash> 8 </bash></p>
<h3>
А теперь подробнее…
</h3>

<p>Естественно, всё вышесказанное - это лишь самые азы. Теперь же необходимо уточнить некоторые детали.</p>
<h4>
Выход из функции
</h4>

<p>В C++, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле написать инструкцию <strong><code>return</code></strong>. Это - точка выхода из тела функции. Кроме того, мы знаем, что точек выхода из тела функции может быть сколько угодно. В Haskell же всё обстоит иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <strong><code>return</code></strong> в Haskell нету.</p>
<p>Да, я понимаю, это удивляет. Мол, а как же нам быть, если мы хотим указать точку выхода явно? Но если мы вспомним математическую природу чистой функции, то поймём, что иначе быть не может. Ведь чистая функция представляет собой описание зависимости выходного выражения от совокупности входных выражений, поэтому её тело представляет собой совокупность выражений, которые вычисляются (в некотором порядке) и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться точкой выхода из функции.</p>
<p>Чтобы стало понятнее, приведу пример:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address <span class="fu">=</span> 
    <span class="kw">if</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span>
    <span class="kw">then</span>
        <span class="st">&quot;localhost&quot;</span>
    <span class="kw">else</span> 
        address</code></pre>
<p>Эта функция принимает единственный аргумент типа <strong><code>String</code></strong>, соответствующий некоему IP-адресу. В теле функции происходит проверка аргумента на равенство адресу “127.0.0.1”, в результате мы оказываемся в одной из двух логических ветвей. Если бы это была функция на C++, это выглядело бы примерно так:</p>
<p>{% highlight cpp %} std::string indicate( const std::string&amp; address ) { if( address == “127.0.0.1” ) { return “localhost”; } else { return address; } } ```</p>
<p>Обратите внимание, что мы явно указали две точки выхода из функции. Но в Haskell это не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, оно и будет возвращено.</p>
<p>А чтобы стало совсем понятно, перепишем тело этой функции для того, чтобы избавиться от выражения <strong><code>if then else</code></strong>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
indicate address <span class="fu">=</span> address</code></pre>
<p>Мы вводим вместо одного тела два, для каждого из которых мы определяем свою зависимость. Мы как бы говорим: “Если входной аргумент будет равен”127.0.0.1“, то пусть возвращаемым функцией значением будет строка”localhost“, если же аргумент будет какой-либо другой, то пусть возвращаемым функцией значением будет сам этот аргумент.” Следовательно, когда компилятор увидит вызов этой функции в коде, он просто <em>подставит</em> на место этого вызова соответствующее выражение: либо строку “localhost”, либо фактически переданный аргумент.</p>
<p>Теперь всё встало на свои места: явно определять точку выхода из чистой функции в Haskell не нужно потому, что конечное выражение в теле этой функции просто заменит собой вызов функции. То есть если написано так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (indicate <span class="st">&quot;127.0.0.1&quot;</span>)</code></pre>
<p>то это то же самое, что было бы написано так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn <span class="st">&quot;localhost&quot;</span></code></pre>
<p>потому что компилятор, вычислив внутренности функции, просто заменит место вызова конечным (итоговым) выражением.</p>
<h4>
Локальные выражения
</h4>

<p>Очень полезно бывает ввести некое локальное значение в теле функции, например, для избавления от дубляжа кода или от магических чисел. Например, у нас есть такая функция:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare_length ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepare_length line <span class="fu">=</span> 
    line <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">4959</span></code></pre>
<p>Итак, мы готовим длину некой линии путём умножения её первоначальной длины на поправочный коэффициент. Но перед нами - магическое число, а это очень плохо. Добавлять комментарий - это не лучшее решение. Поэтому добавим локальное поясняющее выражение:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare_length ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepare_length line <span class="fu">=</span> 
    line <span class="fu">*</span> coefficient
    <span class="kw">where</span> coefficient <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">4959</span></code></pre>
<p>Красиво, не так ли? Ключевое слово <strong><code>where</code></strong> вводит локальное выражение, которое можно использовать в теле функции. Разумеется, локальных выражений может быть несколько:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare_length ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepare_length line <span class="fu">=</span> 
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    <span class="kw">where</span> coefficient <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">4959</span>
          correction <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0012</span></code></pre>
<p>Есть ещё один способ ввести локальное вспомогательное выражение, с помощью ключевого слова <strong><code>let</code></strong>. На примере нашей последней функции это выглядит так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare_length ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepare_length line <span class="fu">=</span> 
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="dv">12</span><span class="fu">.</span><span class="dv">4959</span>
        correction <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0012</span>
    <span class="kw">in</span>
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction</code></pre>
<p>Общая модель такая: <strong><code>let</code></strong> <code>bindings</code> <strong><code>in</code></strong> <code>expression</code>.</p>
<p>Но у вас, очевидно, возник вопрос, в чём же разница между <strong><code>where</code></strong> и <strong><code>let</code></strong>?</p>
<p>Во-первых, выражение <strong><code>where</code></strong> может быть только одно и только в конце тела функции, в то время как выражение <strong><code>let</code></strong> может присутствовать многократно и в любой части тела функции.</p>
<p>Во-вторых, выражение, введённое ключевым словом <strong><code>where</code></strong>, всегда видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <strong><code>let</code></strong>, может быть “супер-локальным”. Например:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare_length ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepare_length line <span class="fu">=</span> 
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="dv">12</span><span class="fu">.</span><span class="dv">4959</span>
        correction <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0012</span>
    <span class="kw">in</span>
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction <span class="fu">-</span> (<span class="kw">let</span> s <span class="fu">=</span> <span class="dv">10</span><span class="fu">.</span><span class="dv">9</span> <span class="kw">in</span> s <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">-</span> s</code></pre>
<p>Понимаю, пример несколько надуманный, но всё-таки… Здесь мы ввели выражение с именем <code>s</code>, которое действует только внутри круглых скобок. Именно поэтому пример этот не скомпилируется, ведь второе выражение <code>s</code> находится уже не в скобках, и поэтому компилятор вполне справедливо возмутится:</p>
<p><bash> [2 of 2] Compiling Main ( src/main.hs, dist/build/Haskell/Haskell-tmp/Main.o )</p>
<p>src/main.hs:43:61: Not in scope: `s’ </bash></p>
<h4>
Про объявление
</h4>

<p>Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Отвечаю: можно, но не рекомендуется.</p>
<p>Общепринятой практикой является объявлять функцию и тут же определять её. И несмотря на то, что мы <em>можем</em> написать так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prepare_length line <span class="fu">=</span> 
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="dv">12</span><span class="fu">.</span><span class="dv">4959</span>
    <span class="kw">in</span>
    line <span class="fu">*</span> coefficient</code></pre>
<p>делать так не рекомендуется, поскольку определение функции становится как бы беднее, ведь сигнатура типов аргументов и возвращаемого выражения помогает лучше понять функцию.</p>
<p>К тому же в случае отсутствия объявления тип аргумента <code>line</code> становится неопределённым, и поэтому строгость проверки этого самого типа (на стадии компиляции) снизится. Если вы делаете это <em>сознательно</em> - три раза подумайте. Во всех же остальных случаях - объявляйте.</p>
<h4>
Вот и всё?
</h4>

<p>Конечно, это далеко не всё, что можно сказать о чистых функциях, но этот базис достаточен для того, чтобы понять суть чистых функций и то, как их можно использовать в своём коде. Продолжение следует…</p>

<div id="socialButtons">
    <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <div class="g-plus" data-action="share" data-annotation="bubble"></div>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'dshevchenko'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

        </div>
        
        <div id="footer">
            <div id="social">
                <strong>let</strong> social = [<span id="twitter"><a href="https://twitter.com/dshevchenko_biz" title="Twitter">t</a></span>, <span id="googleplus"><a href="http://google.com/+DenisShevchenko" title="Google+">g+</a></span>, <span id="github"><a href="https://github.com/denisshevchenko" title="GitHub">g</a></span>, <span id="facebook"><a href="https://www.facebook.com/dshevchenko.biz" title="Facebook">f</a></span>, <span id="linkedin"><a href="https://www.linkedin.com/in/dshevchenkobiz" title="LinkedIn">in</a></span>]
            </div>
            <div id="hakyll_mark">
                Сайт создан с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a> и живёт на <a href="https://github.com/denisshevchenko/blog">GitHub</a>
            </div>
        </div>
        
        <div id="search_form">
            <script>
              (function() {
                var cx = '007697214108744450483:ccjauglh7ao';
                var gcse = document.createElement('script');
                gcse.type = 'text/javascript';
                gcse.async = true;
                gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                    '//www.google.com/cse/cse.js?cx=' + cx;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(gcse, s);
              })();
            </script>
            <gcse:search></gcse:search>
        </div>
        </div>
        </div>
    </body>
</html>
