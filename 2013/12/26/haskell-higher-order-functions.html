<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content="Денис Шевченко">
        <link rel="icon" href="../../../static/images/favicon.ico">

        <title>Haskell: о функциях высшего порядка</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../../static/css/default.css" rel="stylesheet">
        
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

  <body>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58217738-1', 'auto');
      ga('send', 'pageview');

    </script>

    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="logo">
                <a class="navbar-brand" href="../../../" title="Домой">
                  Мысли и опыт
                </a>
              </div>
            </div>
            
            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav">
                <li><a href="../../../tags.html">Темы</a></li>
                <li><a href="../../../archive.html">Архив</a></li>
                <li><a href="../../../feed.xml">RSS</a></li>
              </ul>

              <ul class="nav navbar-nav navbar-right">
                <li><a href="http://dshevchenko.biz" target="_blank">root</a></li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>Haskell: о функциях высшего порядка</h1>

<div class="row">
    <div class="col-xs-5 col-sm-5 col-md-4 col-lg-4">
        <div class="post-info">
            <strong>let</strong> date = "26 декабря 2013"<br />
            &nbsp;&nbsp;&nbsp;&nbsp;tags = [<a href="../../../tags/Haskell.html">Haskell</a>]
        </div>
    </div>

    <div class="col-xs-2 col-sm-2 col-md-4 col-lg-4"></div>
  
    <div class="col-xs-5 col-sm-5 col-md-4 col-lg-4">
        
    </div>
</div>

<p>Функции высшего порядка (higher-order functions) - очень важная и очень интересная особенность языка Haskell. Эта особенность основана на том постулате, что функции в Haskell - это <em>значения</em>. Знаю, это не так легко укладывается в голове, но такова особенность функционального программирования в целом: функции являются значениями (в широком смысле этого слова). Впрочем, если вы прочитали мою прошлую заметку о чистых функциях, вас это уже не должно удивлять, потому что вы уже знаете. что вызов чистой функции в конечном итоге порождает некоторое конечное выражение (являющееся итогом вычисления всех выражений в теле этой функции), которым компилятор заменяет место вызова.</p>
<p>А раз уж функции являются значениями, то их можно, во-первых, передавать другим функциям в качестве аргумента, а во-вторых, возвращать из других функций в качестве выходного значения. Так вот функция A, которая принимает некую функцию B в качестве аргумента и/или возвращает некую функцию C в качестве выходного значения, называется <em>функцией высшего порядка</em>.</p>
<h3>
А теперь начинаем удивляться…
</h3>
<p>Помните, когда я рассказывал вам о чистых функциях, было упомянуто, что такие функции могут принимать как один, так и множество аргументов. На самом деле, я обманул вас, ибо правда такова:</p>
<p><strong>Функции в Haskell всегда принимают только один аргумент. Ни больше, ни меньше.</strong></p>
<p>Но, простите, а как же мы смогли определить функции, принимающие два аргумента?? Отвечаю: это была хитрость. :)</p>
<p>Хитрость это называется “каррирование” (currying), иногда говорят “карринг”. Слово это знаменитое, ибо оно происходит от имени <strong><a href="http://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a></strong>. Да-да, этот тот самый американский математик, в честь которого назвали изучаемый нами язык.</p>
<p>Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую все эти аргументы по одному. Что за ерунда, спросите вы. Поясняю.</p>
<p>Определим функцию деления двух чисел:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
divide arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">/</span> arg2

main <span class="fu">=</span>
    putStrLn (show (divide <span class="fl">10.03</span> <span class="fl">2.1</span>))</code></pre>
<p>Итак, мы определили функцию, принимающую два значения типа <strong><code>Double</code></strong> и возвращающую результат деления первого на второе. Всё предельно просто, не так ли? На самом деле, не так…</p>
<p>Если мы посмотрим “пот капот” вызова этой функции:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">divide <span class="fl">10.03</span> <span class="fl">2.1</span></code></pre>
<p>то узнаем, что вызов этой функции происходит <em>в два этапа</em>:</p>
<ol>
<li>
Функция <code>divide</code> применяется к первому аргументу <code>10.03</code>, вычисляется и возвращает <em>функцию</em> типа <code>Double -&gt; Double</code>.
</li>
<li>
Эта возвращённая функция применяется ко второму аргументу <code>2.1</code>, вычисляется и возвращает конечное значение 4.776190476190476.
</li>
</ol>
<p>На самом деле мы могли бы более явно отразить эту “двуэтапность”, переписав вызов так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre>
<p>Понимаете, да? Функция всегда применяется только к одному аргументу: сначала к 10.03, а потом возвращённая первым вызовом функция применяется к 2.1.</p>
<p>Именно поэтому строка объявления такой функции содержит <em>две</em> стрелочки вместо одной:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></code></pre>
<p>Мы помним, что символ стрелочки говорит нам о функции. Так вот здесь мы видим <em>две</em> стрелочки именно потому, что вызов этой функции происходит в два этапа. И поэтому, строго говоря, неправильно читать это объявление так:</p>
<p>“Функция <code>divide</code> принимает два аргумента типа <strong><code>Double</code></strong> и возвращает значение типа <strong><code>Double</code></strong>.”</p>
<p>Правильно читать так:</p>
<p>“Функция <code>divide</code> принимает первый аргумент типа <strong><code>Double</code></strong> и возвращает функцию типа <strong><code>Double -&gt; Double</code></strong>, принимающую второй аргумент типа <strong><code>Double</code></strong> и возвращающую значение типа <strong><code>Double</code></strong>.”</p>
<p>Более того, это правильное прочтение объявления можно было бы отразить явно и в самом объявлении! Вот так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</code></pre>
<p>Теперь мы явно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа <strong><code>Double -&gt; Double</code></strong>, а на втором этапе происходит уже вызов этой (возвращённой на первом этапе) функции.</p>
<p>По аналогии, если бы у нас была функция, принимающая три аргумента:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">total_sum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
total_sum arg1 arg2 arg3 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2 <span class="fu">+</span> arg3

main <span class="fu">=</span>
    putStrLn (show (total_sum <span class="fl">10.03</span> <span class="fl">2.1</span> <span class="fl">45.7</span>))</code></pre>
<p>то её вызов на самом деле проходил бы <em>в три этапа</em>, и чтобы явно отразить это, мы могли бы переписать её объявление так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">total_sum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>))</code></pre>
<p>а её вызов - так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">((total_sum <span class="fl">10.03</span>) <span class="fl">2.1</span>) <span class="fl">45.7</span></code></pre>
<p>А теперь нам нужно уточнить одну важную деталь.</p>
<h3>
Частичное применение функции
</h3>
<p>Вспомните, что я сказал о функции <code>divide</code>: её вызов происходит <em>в два этапа</em>. Так вот важно понимать, что функция <code>divide</code> вызывается <em>один</em> раз, а не два раза! Вызов один (то есть тело этой функции выполняется единократно), просто этот вызов разделён на два шага. А чтобы понять суть этих шагов, необходимо узнать об одной важной детали: частичное применение функции. Звучит страшновато, но суть очень проста.</p>
<p>Частичное применение (partial application) функции - это такой её вызов, когда ей на вход подаются не все аргументы, которые она ожидает. И здесь нам пригодятся уже известные нам <strong><a href="http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85">λ-функции</a></strong>.</p>
<p>Представим себе, что наша функция <code>divide</code> была бы апплицирована (применена) не к двум, а только к одному аргументу. Тогда это выглядело бы так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> 
    <span class="kw">let</span> temporary_function <span class="fu">=</span> divide <span class="fl">10.03</span> <span class="co">-- &quot;запомнили&quot; первый</span>
    <span class="kw">in</span> 
    putStrLn (show (temporary_function <span class="fl">2.1</span>)) <span class="co">-- получили второй!</span></code></pre>
<p>Вот теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает вызов вида:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre>
<p>В результате первого вызова, когда мы применили функцию <code>divide</code> лишь к одному (первому) аргументу, мы ещё не можем получить результат деления, потому что второго-то аргумента мы функции ещё не дали! Вместо этого мы получили как бы временную (промежуточную) λ-функцию, которую мы для наглядности ассоциировали с выражением <code>temporary_function</code>. Эта временная λ-функция как бы запомнила значение первого аргумента, и когда мы применили её уже ко второму аргументу, то в результате мы уже получили итоговый результат деления.</p>
<p>По аналогии, вызов нашей функции <code>total_sum</code>, который, как мы помним, происходит в три этапа, можно разложить так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">total_sum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
total_sum arg1 arg2 arg3 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2 <span class="fu">+</span> arg3

main <span class="fu">=</span>
    <span class="kw">let</span> first_function <span class="fu">=</span> total_sum <span class="fl">1.0</span> <span class="co">-- &quot;запомнили&quot; первый</span>
        second_function <span class="fu">=</span> first_function <span class="fl">2.0</span> <span class="co">-- &quot;запомнили&quot; второй</span>
    <span class="kw">in</span>
    putStrLn (show (second_function <span class="fl">3.0</span>)) <span class="co">-- получили третий!</span></code></pre>
<p>То есть в процессе вызова у нас появилось уже две промежуточные λ-функции, каждая из которых принимала лишь один аргумент и как бы запоминала его. И только тогда, когда вторая промежуточная λ-функция была апплицирована к третьему аргументу (который и оказался последним необходимым для нас), мы и получаем итоговую сумму.</p>
<p>Разумеется, на практике вводить такие промежуточные λ-функции вам не придётся. Я лишь показал процесс каррирования на практике. Считайте, что мы просто заглянули “под капот” функции и увидели её внутреннюю “пошаговость”.</p>
<h3>
“Ну хорошо, а зачем всё это нужно??”
</h3>
<p>Резонный вопрос. На самом деле, в подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении к аргументам <em>не нужно</em>. Главное преимущество такого подхода, при котором одна функция от нескольких аргументов раскладывается на цепочку функций от одного аргумента каждая, лежит в “академическом измерении”: проводить формальные математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и выдаёт строго одно значение.</p>
<p>Но нас-то с вами, как программистов-практиков, гораздо больше интересует аспект практический, а не академический. И поэтому теперь мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).</p>
<p>Формально функции <code>divide</code> и <code>total_sum</code> являются ФВП, в силу тех самых промежуточных λ-функций. Фактически, все функции, объявленные как принимающие более одного аргумента, являются ФВП. Но на самом деле все эти промежуточные λ-функции - это всего лишь подкапотные дела, они скрыты от наших глаз, в то время как гораздо больший интерес представляют “настоящие” ФВП, которые характеризуются именно тем, что явно объявлены как принимающие на вход реальные функциональные значения и/или возвращающие реальные функциональные значения.</p>
<p>А чтобы разобраться в том, как всё это работает на практике, и понять реальную пользу от ФВП, давайте разберём небольшой пример.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Password</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AvatarURL</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">Integer</span>

<span class="ot">user_info ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
user_info login password avatar_URL user_id <span class="fu">=</span>
    <span class="st">&quot;Full info about user @&quot;</span> <span class="fu">++</span> (show user_id) <span class="fu">++</span> <span class="st">&quot;:&quot;</span> <span class="fu">++</span>
    <span class="st">&quot;\n login: &quot;</span> <span class="fu">++</span> login <span class="fu">++</span>
    <span class="st">&quot;\n password: &quot;</span> <span class="fu">++</span> password <span class="fu">++</span>
    <span class="st">&quot;\n avatar URL: &quot;</span> <span class="fu">++</span> avatar_URL

<span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">store_login_in ::</span> <span class="dt">EmptyInfo</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">WithLogin</span>
store_login_in empty_info user_id <span class="fu">=</span>
    empty_info <span class="st">&quot;denis&quot;</span>
    <span class="co">-- В реальности логин будет получен </span>
    <span class="co">-- в соответствии с переданным user_id</span>

<span class="ot">store_password_in ::</span> <span class="dt">WithLogin</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithPassword</span>
store_password_in info_with_login user_id <span class="fu">=</span>
    info_with_login <span class="st">&quot;123456789abc&quot;</span>
    <span class="co">-- В реальности пароль будет получен </span>
    <span class="co">-- в соответствии с переданным user_id</span>

<span class="ot">store_avatar_URL_in ::</span> <span class="dt">AndWithPassword</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithAvatarURL</span>
store_avatar_URL_in info_with_password user_id <span class="fu">=</span>
    info_with_password <span class="st">&quot;http://dshevchenko.biz/denis_avatar.png&quot;</span>
    <span class="co">-- В реальности URL будет получен </span>
    <span class="co">-- в соответствии с переданным user_id</span>

main <span class="fu">=</span>
    <span class="kw">let</span> user_id <span class="fu">=</span> <span class="dv">1234</span>
        info_with_login <span class="fu">=</span> store_login_in user_info 
                                         user_id
        info_with_password <span class="fu">=</span> store_password_in info_with_login 
                                               user_id
        info_with_avatar_URL <span class="fu">=</span> store_avatar_URL_in info_with_password 
                                                   user_id
        full_info_about_user <span class="fu">=</span> info_with_avatar_URL user_id
    <span class="kw">in</span>
    putStrLn full_info_about_user</code></pre>
<p>Красиво, не так ли? Давайте разберём это хозяйство по косточкам…</p>
<p>Во-первых, новая для нас конструкция вида:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span></code></pre>
<p>Очевидно, вы уже догадались, что это всего лишь добавление псевдонима для (уже известного) типа. Теперь вместо типа <strong><code>String</code></strong> можно использовать идентификатор <code>Login</code>.</p>
<p>Далее мы определили простую функцию вида:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">user_info ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Тут всё просто: функция <code>user_info</code> ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую результирующую строку.</p>
<p>А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется лишь некий идентификатор пользователя, а соответствующие этому идентификатору логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, откуда получить логин, пароль и путь к аватару соответственно. Причём каждая из этих трёх функций является ФВП!</p>
<p>Обратите внимание на следующие псевдонимы:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Каждый из них вводит упрощающее имя для функционального типа, образованного от типа функции <code>user_info</code>. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Чтобы было понятнее, изобразим это с соответствующими сдвигами:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="dt">WithLogin</span> <span class="fu">=</span>          <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="dt">AndWithPassword</span> <span class="fu">=</span>                <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="dt">AndWithAvatarURL</span> <span class="fu">=</span>                            <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Каждый из этих псевдонимов задаёт сигнатуру для (очередной) промежуточной λ-функции, и нужно это, как вы уже догадались, для упомянутого выше частичного применения функции <code>user_info</code>.</p>
<p>Рассмотрим первый вызов:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">        info_with_login <span class="fu">=</span> store_login_in user_info 
                                         user_id</code></pre>
<p>Здесь мы передаём функцию <code>user_info</code> в качестве первого аргумента функции <code>store_login_in</code>, внутри которой мы апплицируем переданную функцию <code>user_info</code> к единственному аргументу, а именно к логину (потому что функция <code>store_login_in</code> знает только о том, откуда и как получить логин). Соответственно, на выходе из функции <code>store_login_in</code> мы получаем первую промежуточную λ-функцию, в которой мы как бы сохранили (store) значение логина (именно поэтому сигнатура этой λ-функции названа <code>WithLogin</code>).</p>
<p>Далее следует вызов:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">        info_with_password <span class="fu">=</span> store_password_in info_with_login 
                                               user_id</code></pre>
<p>Здесь мы передаём нашу промежуточную λ-функцию (в которой мы как бы сохранили значение логина) в качестве первого аргумента функции <code>store_password_in</code>. Эта функция, в свою очередь, апплицирует переданную ей λ-функцию к единственному аргументу, а именно к паролю (ибо функция <code>store_password_in</code>, как вы уже поняли, умеет доставать только пароль). Таким образом, на выходе из функции <code>store_password_in</code> мы имеем вторую промежуточную λ-функцию, в которой как бы сохранены уже два значения (полученный на предыдущем вызове логин и на этом вызове - пароль), именно поэтому сигнатура этой λ-функции носит имя <code>AndWithPassword</code>.</p>
<p>То же самое справедливо и для следующего вызова:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">        info_with_avatar_URL <span class="fu">=</span> store_avatar_URL_in info_with_password 
                                                   user_id</code></pre>
<p>На выходе из функции <code>store_avatar_URL_in</code> мы получаем третью λ-функцию, в которой как бы сохранены уже три значения: логин, пароль и путь к аватару.</p>
<p>В итоге всё завершается апплицированием этой третьей λ-функции к последнему нужному аргументу, а именно к идентификатору пользователя:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">        full_info_about_user <span class="fu">=</span> info_with_avatar_URL user_id</code></pre>
<p>Именно здесь и происходит наконец “полноценный” вызов функции <code>user_info</code>, в результате которого мы получаем и выводим на экран результирующую строку следующего вида:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Full</span> info about user @1234:
 <span class="kw">login</span>: denis
 <span class="kw">password</span>: 123456789abc
 <span class="kw">avatar</span> URL: http://dshevchenko.biz/denis_avatar.png</code></pre>
<p>Таким образом, функция <code>user_info</code> была частично апплицирована три раза (каждый раз получая очередной аргумент), и лишь на четвёртый она получила все четыре необходимых ей аргумента. Мы можем сравнить это с конвейерной цепочкой, которую прошла данная функция: на каждом шаге она получала очередной аргумент.</p>
<p>Итак, перед нами - живая демонстрация реальной пользы ФВП. Да, признаю, этот пример можно было бы упростить (в данном конкретном случае можно было обойтись без частичного применения), но цель была не в том, чтобы дать на 100% оптимальное решение, а в том чтобы продемонстрировать упомянутую выше теорию на практическом примере. И как вы смогли убедиться, эта теория лишь поначалу казалось нам страшноватой, в реальности же она достаточно проста.</p>

<div id="socialButtons">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ru">Твитнуть</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <div class="g-plus" data-action="share" data-annotation="bubble"></div>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'dshevchenko'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

        </div> 

        <div id="searchForm">
            <script>
              (function() {
                var cx = '007697214108744450483:ccjauglh7ao';
                var gcse = document.createElement('script');
                gcse.type = 'text/javascript';
                gcse.async = true;
                gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                    '//www.google.com/cse/cse.js?cx=' + cx;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(gcse, s);
              })();
            </script>
            <gcse:search></gcse:search>
        </div>

        <footer class="footer">
            Сайт работает на <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/denisshevchenko/blog" target="_blank">GitHub</a></strong>.
            <div class="copyright-note">
                Исходный код данного сайта, а также все опубликованные на нём материалы распространяются на условиях <a href="https://github.com/denisshevchenko/blog/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>
  </body>
</html>

