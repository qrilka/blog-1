<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Haskell: о лямбда-функциях</title>
        <link rel="stylesheet" type="text/css" href="../../../css/default.css" />

        <link href="http://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700⊂=cyrillic-ext,latin" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Anonymous+Pro⊂=latin,cyrillic" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Bad+Script⊂=latin,cyrillic" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Fira+Mono:400,700⊂=latin,latin-ext" rel="stylesheet" type="text/css">

        <link rel="icon" type="image/x-icon" href="../../../images/favicon.ico" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../" title="Домой">Д. Шевченко</a><span class="logo-note">Программист, исследователь, писатель</span>
            </div>
            <div id="navigation">
                <a href="http://dshevchenko.biz" title="К корневому сайту"><span id="root_link">cd /</span></a>
                <a href="../../../archive.html">Архив</a>
            </div>
        </div>

        <div id="content">
            <h1>Haskell: о лямбда-функциях</h1>

            <div class="info">
    (2013, 12, 20)
</div>

<div style="padding-top: 20px;"></div>

<p>Помню как в школе я довольно долго не мог понять, что же такое функция. Да, я уже решал многие задания с использованием функций, да, уже рисовал разнообразные графики (помните эти прелестные дуги на тетрадном листе в клеточку?), но при этом не мог бы объяснить ребёнку, что такое функция как <em>понятие</em>. А памятуя о мудрых словах Эйнштейна, если вы не можете объяснить некую идею пятилетнему ребёнку, значит вы и сами её не понимаете…</p>
<p>А ведь понятие-то оказалось предельно простым:</p>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>
<p>Всё. Если у нас есть описание того, <em>как</em> конкретное входное значение определяет конкретное выходное значение - значит это описание и есть функция.</p>
<p>Однако в мире языка C (и подобных ему языков) функция никогда не ассоциировалась с таким определением. Напротив, функция там есть не что иное, как <em>подпрограмма</em>, а имя функции есть не что иное, как указатель на первую инструкцию этой подпрограммы.</p>
<p>Кроме того, функция в C является глобальной в рамках текущей единицы трансляции. И поэтому вызов функции - это как бы “глобальный <strong><code>goto</code></strong>” в её тело (с последующим возвратом из него). Именно поэтому функция в языке C не может быть безымянной, потому что иначе её невозможно было бы вызывать.</p>
<p>Всё это я напоминаю вам для того, чтобы, продолжив чтение этой заметки, вы увидели, насколько концепция λ-функций отличается от концепции функций в языке C.</p>
<h3>
Так что же это за лямбды такие?
</h3>

<p>В основе идеи λ-функций лежит λ-исчисление, названное так по имени этой красивой греческой буквы. У понятия λ-исчисления довольно-таки долгая академическая история, нам нет смысла её здесь разбирать по косточкам. Нас интересует лишь суть, поэтому сразу пример.</p>
<p>Представим себе, что нам нужна функция, принимающая некое целочисленное значение и возвращающая квадрат этого значения. Причём функция именно в том самом, математическом смысле. Как бы мы могли это отобразить? Примерно так:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">5</span> -&gt; f -&gt; <span class="dv">25</span></code></pre>
<p>Итак, подаём на вход значение 5, а на выходе получаем 25. Проще некуда. Но как же нам записать внутренности функции <code>f</code>? Ну, например, так:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">5</span> -&gt; (x * x) -&gt; <span class="dv">25</span></code></pre>
<p>Тут тоже всё ясно: поданный на вход аргумент умножается сам на себя.</p>
<p>Ну а теперь главный вопрос: как эту функцию описать <em>формально</em>, или <em>унифицированно</em>? Вот тут-то на сцену и выходит λ-исчисление, ибо оно как раз и предлагает такой вот унифицированный способ записи функции.</p>
<p>Вот λ-выражение для нашей функции:</p>
<pre>
λx.x*x
</pre>

<p>Буква λ - это признак λ-функции. А читать это выражение следует примерно так:</p>
<p>λ-функция от одного аргумента <code>x</code>, умножающая этот аргумент сам на себя.</p>
<p>Таким образом, выражение до разделяющей точки:</p>
**
<pre>
λx
</pre>
<p>**</p>
<p>это список аргументов (в данном случае он один), а выражение после разделяющей точки:</p>
**
<pre>
x*x
</pre>
<p>**</p>
<p>это “тело” функции, описывающее ту самую зависимость выходного значения от значения входного.</p>
<p>Как видите, весьма простое и элегантное описание. Как говорится, ничего лишнего.</p>
<p>Обратите также внимание на то, что здесь нет имени. Особенностью λ-функции является её безымянность. Почему? Потому что имя ей не нужно. И это принципиально отличает её от функции в языке C, потому что там я могу обратиться к функции не иначе, как через её имя (даже вызов через указатель всё равно требует хотя бы единократное использование имени функции).</p>
<h3>
Ну хорошо, а как это будет выглядеть в коде?
</h3>

<p>λ-функции присутствуют во многих языках программирования. Но есть один язык, в котором синтаксис λ-выражения максимально приближен к приведённому здесь математическому. Угадайте с трёх раз, о каком языке я говорю… :)</p>
<p>Итак, вот наша функция в Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x</code></pre>
<p>Ну, что я говорил? Прямое сходство. Ведь даже обратный слэш вначале подходит как нельзя лучше: рассматривайте его как “спинку” буквы λ. Фактически, единственное отличие - это замена точки стрелочкой, потому что символ ‘<code>-&gt;</code>’ присущ языку Haskell как признак (любой) функции. Нда-с, сразу чувствуется, что язык Haskell создал математик.</p>
<p>А теперь, вероятно, вас интересует, как же можно <em>вызывать</em> такую функцию? Вероятно, мой ответ удивит вас, но λ-функции, строго говоря, не вызывают.</p>
<p>Да-да, я уже вижу расширающиеся от удивления глаза. Точно такие же были и у меня, когда я впервые прочитал об этом. Но на самом деле здесь имеет место лишь игра слов. А для того, чтобы всё встало на свои места, мы опять вынуждены на пару минут вернуться в математику.</p>
<p>Идея λ-функции базируется на принципе “аппликации” (application), или “применения”. Это означает, что λ-функции не вызывают, а применяют (или, если хотите, прикладывают) к аргументу. Знаю, это звучит странновато для уха программистов из мира C, потому что там аргумент “прикладывают” к функции, но в математике договорились на таком определении. Поэтому запись вида:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">f a</code></pre>
<p>принято читать так: применение функции <code>f</code> к аргументу <code>a</code>.</p>
<p>Вот как это выглядит в Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x) <span class="dv">5</span></code></pre>
<p>Как видите, тут тоже прямое сходство с математической записью. Выражение в скобках - это уже знакомое нам λ-выражение. Оно “порождает” λ-функцию, которая сразу же применяется (прикладывается) к аргументу 5, результатом чего и явится значение 25.</p>
<p>Таким образом, можно сказать, что перед нами - вызов λ-функции с аргументом 5, но учитывая математические корни языка Haskell, можно сказать, что перед нами - применение λ-функции к аргументу 5.</p>
<h3>
Да, но какая же от всего этого польза?
</h3>

<p>Действительно, пора и к практике переходить.</p>
<p>В языке C принят стандартный “круг трёх шагов” по работе с функцией:</p>
<ol>
  <li>
объявление,
</li>
  <li>
определение,
</li>
  <li>
вызов.
</li>
</ol>

<p>И потому работа с нашей функцией возведения в квадрат, применительно к языку C, могла бы выглядеть так:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> i ) {
    <span class="kw">return</span> i * i;
}

<span class="dt">int</span> main() {
    printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, f( <span class="dv">5</span> ) );
}</code></pre>
<p>Мы подготовили нашу “глобальную подпрограмму”, в которую чуть позже зайдём через вызов (фактически - через разыменование указателя <code>f</code>).</p>
<p>А вот как это выглядело бы на Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    putStrLn (show ((\x <span class="ot">-&gt;</span> x <span class="fu">*</span> x) <span class="dv">5</span>))</code></pre>
<p>Как видите, мы ничего не готовим заранее. Напротив, мы <em>создаём</em> функцию (или, если хотите, функциональный объект) локально и непосредственно перед использованием. Создаём - и сразу апплицируем его к аргументу 5.</p>
<p>Для большей простоты и похожести на нашу функцию мы можем написать и так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    <span class="kw">do</span> putStrLn (show (f <span class="dv">5</span>))
    <span class="kw">where</span> f <span class="fu">=</span> (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x)</code></pre>
<p>Выражение</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">where</span> f <span class="fu">=</span> (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x)</code></pre>
<p>это не присваивание (напомню, в Haskell его нет), это как бы ассоциация. Мы вводим локальный псевдоним для λ-функции и называем его <code>f</code>.</p>
<p>Вы можете спросить меня, мол, какова же реальная польза от λ-функции, если у нас есть функция обыкновенная? Ведь мы могли бы написать и так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
f x <span class="fu">=</span>
    x <span class="fu">*</span> x

main <span class="fu">=</span>
    putStrLn (show (f <span class="dv">5</span>))</code></pre>
<p>Тут всё как обычно: мы определили функцию <code>f</code> заранее, а потом апплицировали её к аргументу 5.</p>
<p>Так вот одно из преимуществ λ-функции как раз и заключается в её локальности. Зачем нам определять (подготавливать заранее) некую “глобальную подпрограмму”, если мы можем создать и использовать её непосредственно в том месте, где она нужна? Очень часто в реальных программах случается такое, что функция определяется лишь для того, чтобы быть вызванной в одном-единственном месте. Ну и зачем же нам определяеть её “глобально”?</p>
<p>Анонимность λ-функции также видится мне преимуществом, по крайней мере в ряде случаев. Если действие, совершаемое с помощью конкретной λ-функции, тривиально (и может быть понято из её “тела”, как в случае с функцией возведения в квадрат) - зачем же нам придумывать имя? Мы можем спокойно обойтись без него. Однако, в том случае, когда λ-функция нужна нам во многих местах кода, мы можем, во избежание дубляжа, “определить” λ-функцию глобально. Делается это в нашем случае так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> \x <span class="ot">-&gt;</span> x <span class="fu">*</span> x

main <span class="fu">=</span>
    <span class="kw">do</span> putStrLn (show ((f <span class="dv">5</span>) <span class="fu">+</span> (f <span class="dv">6</span>)))</code></pre>
<p>Как видите, мы “определили” нашу функцию глобально и ассоциировали её с выражением <code>f</code>. Теперь мы можем многократно использовать это выражение в коде, для апплицирования его к различным аргументам (в данном случае к 5 и к 6).</p>
<p>Ну вот, собственно, и всё. Конечно, это далеко не вся информация о λ-функциях, но этого базиса нам пока достаточно. Продолжение следует…</p>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'dshevchenko'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

        </div>
        
        <div id="footer">
            <div id="social">
                <strong>let</strong> social = [<span id="twitter"><a href="https://twitter.com/dshevchenko_biz" title="Twitter">t</a></span>, <span id="googleplus"><a href="http://google.com/+DenisShevchenko" title="Google+">g+</a></span>, <span id="github"><a href="https://github.com/denisshevchenko" title="GitHub">g</a></span>, <span id="facebook"><a href="https://www.facebook.com/dshevchenko.biz" title="Facebook">f</a></span>, <span id="linkedin"><a href="https://www.linkedin.com/in/dshevchenkobiz" title="LinkedIn">in</a></span>]
            </div>
            <div id="hakyll_mark">
                Сайт создан с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a> и живёт на <a href="https://github.com/denisshevchenko/blog">GitHub</a>
            </div>
        </div>
        
        <div id="search_form">
            <script>
              (function() {
                var cx = '007697214108744450483:ccjauglh7ao';
                var gcse = document.createElement('script');
                gcse.type = 'text/javascript';
                gcse.async = true;
                gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                    '//www.google.com/cse/cse.js?cx=' + cx;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(gcse, s);
              })();
            </script>
            <gcse:search></gcse:search>
        </div>
    </body>
</html>
