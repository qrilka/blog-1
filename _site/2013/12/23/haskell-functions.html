<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<link href='http://fonts.googleapis.com/css?family=Cuprum:400,400italic,700&subset=latin,cyrillic,latin-ext' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Lobster&subset=latin,cyrillic,latin-ext' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Philosopher:400,400italic,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
<title>Haskell: о функциях &#8211; Мысли вслух</title>
<meta name="description" content="блог C++-программиста, влюбившегося в Haskell">
<meta name="keywords" content="Haskell">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.dshevchenko.biz/images/site-logo.png">
<meta name="twitter:title" content="Haskell: о функциях">
<meta name="twitter:description" content="блог C++-программиста, влюбившегося в Haskell">
<meta name="twitter:creator" content="@dshevchenko_biz">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell: о функциях">
<meta property="og:description" content="блог C++-программиста, влюбившегося в Haskell">
<meta property="og:url" content="http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html">
<meta property="og:site_name" content="Мысли вслух">





<link rel="canonical" href="http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html">
<link href="http://blog.dshevchenko.biz/feed.xml" type="application/atom+xml" rel="alternate" title="Мысли вслух Feed">
<link rel="author" href="https://google.com/+DenisShevchenko?rel=author">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://blog.dshevchenko.biz/assets/css/main.min.css">
<!-- Webfonts -->
<script src="//use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://blog.dshevchenko.biz/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://blog.dshevchenko.biz/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://blog.dshevchenko.biz/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://blog.dshevchenko.biz/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://blog.dshevchenko.biz/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://blog.dshevchenko.biz/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://blog.dshevchenko.biz/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
	        
			<li>
				
					<a href="http://blog.dshevchenko.biz/articles/">Записи</a>
				 
			</li>
	        
			<li>
				
					<a href="http://blog.dshevchenko.biz/tags/">Метки</a>
				 
			</li>
	        
	        <li><a href="http://blog.dshevchenko.biz/feed.xml" title="Atom/RSS feed"><i class="icon-rss"></i> Feed</a></li>
	        <li class="dosearch"><i class="icon-search"></i> Поиск</li>
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->

<div class="search-wrapper">
	<div class="search-form">
		<input type="text" class="search-field" placeholder="Ищем...">
		<i class="icon-remove-sign icon-2x"></i>
		<ul class="search-results post-list"></ul><!-- /.search-results -->
	</div><!-- /.search-form -->
</div><!-- ./search-wrapper -->

<header class="masthead">
	<div class="wrap">
        
    		<a href="http://blog.dshevchenko.biz/" class="site-logo" rel="home" title="Мысли вслух"><img src="http://blog.dshevchenko.biz/images/site-logo.png" width="200" height="200" alt="Мысли вслух logo" class="animated fadeInUp"></a>
        
        <h1 class="site-title animated fadeIn"><a href="http://blog.dshevchenko.biz/">Мысли вслух</a></h1>
		<h2 class="site-description animated fadeIn" itemprop="description">блог C++-программиста, влюбившегося в Haskell</h2>
	</div>
</header><!-- /.masthead -->


<div id="main" role="main">
  <article class="hentry">
    
    <div class="entry-wrapper">
      <header class="entry-header">
        <span class="entry-tags"><a href="http://blog.dshevchenko.biz/tags/#Haskell" title="Pages tagged Haskell">Haskell</a></span>
        
          <h1 class="entry-title">Haskell: о функциях</h1>
        
      </header>
      <footer class="entry-meta">
        <!-- <img src="http://blog.dshevchenko.biz/images/bio-photo.jpg" alt="Денис Шевченко photo" class="author-photo">
        <span class="author vcard">By <span class="fn"><a href="http://blog.dshevchenko.biz/about/" title="About Денис Шевченко">Денис Шевченко</a></span></span> -->
        <span class="entry-date date published"><time datetime="2013-12-23T00:00:00+04:00"><i class="icon-calendar-empty"></i> декабрь 23, 2013</time></span>
        
        <span><a href="http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html" rel="bookmark" title="Haskell: о функциях"><i class="icon-link"></i> Вечная ссылка</a></span>
        <span class="entry-comments"><i class="icon-comment-alt"></i> <a href="#disqus_thread">Комментарии</a></span>
        
        <span class="social-share-facebook">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html" title="Share on Facebook" itemprop="Facebook"><i class="icon-facebook-sign"></i> Like</a></span>
        <span class="social-share-twitter">
            <a href="https://twitter.com/intent/tweet?hashtags=articles&text=Haskell: о функциях&url=http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html&via=dshevchenko_biz" title="Share on Twitter" itemprop="Twitter"><i class="icon-twitter-sign"></i> Tweet</a></span>
        <span class="social-share-googleplus">
            <a href="https://plus.google.com/share?url=http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html" title="Share on Google Plus" itemprop="GooglePlus"><i class="icon-google-plus-sign"></i> +1</a></span>
            <!-- /.social-share -->
      </footer>
      <div class="entry-content">
        <p>Если вы помните <strong><a href="http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85">заметку о лямбда-функциях</a></strong>, математическое определение функции очень простое:</p>

<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>

<p>Так вот чистые функции в языке Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, <em>как</em> входное выражение (или совокупность таковых) определяет выходное выражение. Именно поэтому они не имеют побочных эффектов, и если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз получим один и тот же ответ.</p>

<p>А теперь за дело.</p>

<h3>Объявляем</h3>

<p>Начинается всё с объявления функции:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">simple_sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</code></pre></div>

<p>Перед нами - объявление выражения. До символа <code>::</code> указывается имя выражения, а после - тип выражения. </p>

<div class="highlight"><pre><code class="haskell"><span class="nf">simple_sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="o">|</span>        <span class="o">|</span>    <span class="o">|</span>        <span class="o">|</span>
   <span class="err">имя</span>           <span class="err">тип</span>
</code></pre></div>

<p>Итак, перед нами выражение с именем <code>simple_sum</code>, имеющее тип функции. Пусть вас не смущают эти слова: в Haskell функция - это тоже тип. Но откуда же мы знаем, что тип этого выражения представляет собой именно функцию? Давайте рассмотрим описание типа подробнее:</p>

<div class="highlight"><pre><code class="haskell"><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</code></pre></div>

<p>Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами функция. Слева от неё указан тип единственного аргумента функции (в данном случае это стандартный тип <strong><code>Int</code></strong>), а справа от неё - тип выходного выражения (тот же <strong><code>Int</code></strong>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации через функцию - от входа к выходу, слева направо.</p>

<p>В силу того, что чистая функция в Haskell является математической, невозможно написать аналоги вот таких C-шных функций:</p>

<div class="highlight"><pre><code class="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">);</span>
</code></pre></div>

<p>Чистая функция в Haskell обязана иметь входной аргумент (хотя бы один) и выходное значение. Почему? Потому что это отражает суть математической функции: что-то <em>обязательно</em> подаём на вход и что-то <em>обязательно</em> получаем на выходе.</p>

<p>Кстати, о количестве аргументнов. Разумеется, чистая функция может принимать несколько аргументов. В этом случае её тип будет выглядеть так:</p>

<div class="highlight"><pre><code class="haskell"><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</code></pre></div>

<p>Я понимаю, выглядит чуток странно, но читать это очень просто: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:</p>

<div class="highlight"><pre><code class="haskell"><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="err">типы</span> <span class="err">аргументов</span>  <span class="o">|</span>  <span class="o">|</span> <span class="err">тип</span> <span class="err">того</span><span class="p">,</span> <span class="err">что</span> <span class="err">будет</span> <span class="err">на</span> <span class="err">выходе</span> 
</code></pre></div>

<p>Итак, с объявлением разобрались. Идём дальше.</p>

<h3>Определяем</h3>

<p>Теперь функцию нужно определить. Кстати, определить нужно <em>обязательно</em>. Известно, что в том же C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда нигде не вызывается). В Haskell более строгий подход: если объявил - будь добр и определить, в противном случае компилятор выскажет своё недовольство.</p>

<p>Итак, сразу после объявления пишем тело функции:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">simple_sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">simple_sum</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">value</span>
</code></pre></div>

<p>Рассмотрим его подробнее:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">simple_sum</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">value</span>
</code></pre></div>

<p>Здесь ментальным разделителем является знак равенства. Напоминаю, что в Haskell нет оператора присваивания, поэтому знак равенства здесь - это именно <em>знак равенства</em>, как в математике. Скелет данного выражения можно представить так:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">name</span> <span class="n">arguments</span> <span class="ow">=</span> <span class="n">body_expression</span>
</code></pre></div>

<p>Здесь:</p>

<ul>
  <li><code>name</code> - имя функции.</li>
  <li><code>arguments</code> - список имён аргументов (именно имён, а не их типов).</li>
  <li><code>body_expression</code> - тело функции.</li>
</ul>

<p>В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется чрезвычайно простое тело, в котором мы просто-напросто складываем аргумент с самим собой.</p>

<h3>Вызываем</h3>

<p>Теперь нашу функцию можно вызывать с аргументом 4 (или, как привычно говорить в мире ФП, апплицировать функцию к аргументу 4):</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="p">(</span><span class="n">simple_sum</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div>

<p>В ответ получаем ожидаемое значение:</p>

<bash>
8
</bash>

<h3>А теперь подробнее...</h3>

<p>Естественно, всё вышесказанное - это лишь самые азы. Теперь же необходимо уточнить некоторые детали.</p>

<h4>Выход из функции</h4>

<p>В C++, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле написать инструкцию <strong><code>return</code></strong>. Это - точка выхода из тела функции. Кроме того, мы знаем, что точек выхода из тела функции может быть сколько угодно. В Haskell же всё обстоит иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <strong><code>return</code></strong> в Haskell нету.</p>

<p>Да, я понимаю, это удивляет. Мол, а как же нам быть, если мы хотим указать точку выхода явно? Но если мы вспомним математическую природу чистой функции, то поймём, что иначе быть не может. Ведь чистая функция представляет собой описание зависимости выходного выражения от совокупности входных выражений, поэтому её тело представляет собой совокупность выражений, которые вычисляются (в некотором порядке) и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться точкой выхода из функции.</p>

<p>Чтобы стало понятнее, приведу пример:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">indicate</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">indicate</span> <span class="n">address</span> <span class="ow">=</span> 
    <span class="kr">if</span> <span class="n">address</span> <span class="o">==</span> <span class="s">&quot;127.0.0.1&quot;</span>
    <span class="kr">then</span>
        <span class="s">&quot;localhost&quot;</span>
    <span class="kr">else</span> 
        <span class="n">address</span>
</code></pre></div>

<p>Эта функция принимает единственный аргумент типа <strong><code>String</code></strong>, соответствующий некоему IP-адресу. В теле функции происходит проверка аргумента на равенство адресу “127.0.0.1”, в результате мы оказываемся в одной из двух логических ветвей. Если бы это была функция на C++, это выглядело бы примерно так:</p>

<div class="highlight"><pre><code class="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">indicate</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">address</span> <span class="o">==</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;localhost&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Обратите внимание, что мы явно указали две точки выхода из функции. Но в Haskell это не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, оно и будет возвращено.</p>

<p>А чтобы стало совсем понятно, перепишем тело этой функции для того, чтобы избавиться от выражения <strong><code>if then else</code></strong>:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">indicate</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">indicate</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="ow">=</span> <span class="s">&quot;localhost&quot;</span>
<span class="nf">indicate</span> <span class="n">address</span> <span class="ow">=</span> <span class="n">address</span>
</code></pre></div>

<p>Мы вводим вместо одного тела два, для каждого из которых мы определяем свою зависимость. Мы как бы говорим: “Если входной аргумент будет равен “127.0.0.1”, то пусть возвращаемым функцией значением будет строка “localhost”, если же аргумент будет какой-либо другой, то пусть возвращаемым функцией значением будет сам этот аргумент.” Следовательно, когда компилятор увидит вызов этой функции в коде, он просто <em>подставит</em> на место этого вызова соответствующее выражение: либо строку “localhost”, либо фактически переданный аргумент.</p>

<p>Теперь всё встало на свои места: явно определять точку выхода из чистой функции в Haskell не нужно потому, что конечное выражение в теле этой функции просто заменит собой вызов функции. То есть если написано так:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">indicate</span> <span class="s">&quot;127.0.0.1&quot;</span><span class="p">)</span>
</code></pre></div>

<p>то это то же самое, что было бы написано так:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;localhost&quot;</span>
</code></pre></div>

<p>потому что компилятор, вычислив внутренности функции, просто заменит место вызова конечным (итоговым) выражением.</p>

<h4>Локальные выражения</h4>

<p>Очень полезно бывает ввести некое локальное значение в теле функции, например, для избавления от дубляжа кода или от магических чисел. Например, у нас есть такая функция:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="n">line</span> <span class="o">*</span> <span class="mf">0.4959</span>
</code></pre></div>

<p>Итак, мы готовим длину некой линии путём умножения её первоначальной длины на поправочный коэффициент. Но перед нами - магическое число, а это очень плохо. Добавлять комментарий - это не лучшее решение. Поэтому добавим локальное поясняющее выражение:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="n">line</span> <span class="o">*</span> <span class="n">coefficient</span>
    <span class="kr">where</span> <span class="n">coefficient</span> <span class="ow">=</span> <span class="mf">0.4959</span>
</code></pre></div>

<p>Красиво, не так ли? Ключевое слово <strong><code>where</code></strong> вводит локальное выражение, которое можно использовать в теле функции. Разумеется, локальных выражений может быть несколько:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="n">line</span> <span class="o">*</span> <span class="n">coefficient</span> <span class="o">-</span> <span class="n">correction</span>
    <span class="kr">where</span> <span class="n">coefficient</span> <span class="ow">=</span> <span class="mf">0.4959</span>
          <span class="n">correction</span> <span class="ow">=</span> <span class="mf">0.0012</span>
</code></pre></div>

<p>Есть ещё один способ ввести локальное вспомогательное выражение, с помощью ключевого слова <strong><code>let</code></strong>. На примере нашей последней функции это выглядит так:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="kr">let</span> <span class="n">coefficient</span> <span class="ow">=</span> <span class="mf">12.4959</span>
        <span class="n">correction</span> <span class="ow">=</span> <span class="mf">0.0012</span>
    <span class="kr">in</span>
    <span class="n">line</span> <span class="o">*</span> <span class="n">coefficient</span> <span class="o">-</span> <span class="n">correction</span>
</code></pre></div>

<p>Общая модель такая: <strong><code>let</code></strong> <code>bindings</code> <strong><code>in</code></strong> <code>expression</code>.</p>

<p>Но у вас, очевидно, возник вопрос, в чём же разница между <strong><code>where</code></strong> и <strong><code>let</code></strong>?</p>

<p>Во-первых, выражение <strong><code>where</code></strong> может быть только одно и только в конце тела функции, в то время как выражение <strong><code>let</code></strong> может присутствовать многократно и в любой части тела функции.</p>

<p>Во-вторых, выражение, введённое ключевым словом <strong><code>where</code></strong>, всегда видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <strong><code>let</code></strong>, может быть “супер-локальным”. Например:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="kr">let</span> <span class="n">coefficient</span> <span class="ow">=</span> <span class="mf">12.4959</span>
        <span class="n">correction</span> <span class="ow">=</span> <span class="mf">0.0012</span>
    <span class="kr">in</span>
    <span class="n">line</span> <span class="o">*</span> <span class="n">coefficient</span> <span class="o">-</span> <span class="n">correction</span> <span class="o">-</span> <span class="p">(</span><span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="mf">10.9</span> <span class="kr">in</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span>
</code></pre></div>

<p>Понимаю, пример несколько надуманный, но всё-таки… Здесь мы ввели выражение с именем <code>s</code>, которое действует только внутри круглых скобок. Именно поэтому пример этот не скомпилируется, ведь второе выражение <code>s</code> находится уже не в скобках, и поэтому компилятор вполне справедливо возмутится:</p>

<bash>
[2 of 2] Compiling Main             ( src/main.hs, dist/build/Haskell/Haskell-tmp/Main.o )

src/main.hs:43:61: Not in scope: `s'
</bash>

<h4>Про объявление</h4>

<p>Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Отвечаю: можно, но не рекомендуется.</p>

<p>Общепринятой практикой является объявлять функцию и тут же определять её. И несмотря на то, что мы <em>можем</em> написать так:</p>

<div class="highlight"><pre><code class="haskell"><span class="nf">prepare_length</span> <span class="n">line</span> <span class="ow">=</span> 
    <span class="kr">let</span> <span class="n">coefficient</span> <span class="ow">=</span> <span class="mf">12.4959</span>
    <span class="kr">in</span>
    <span class="n">line</span> <span class="o">*</span> <span class="n">coefficient</span>
</code></pre></div>

<p>делать так не рекомендуется, поскольку определение функции становится как бы беднее, ведь сигнатура типов аргументов и возвращаемого выражения помогает лучше понять функцию.</p>

<p>К тому же в случае отсутствия объявления тип аргумента <code>line</code> становится неопределённым, и поэтому строгость проверки этого самого типа (на стадии компиляции) снизится. Если вы делаете это <em>сознательно</em> - три раза подумайте. Во всех же остальных случаях -  объявляйте.</p>

<h4>Вот и всё?</h4>

<p>Конечно, это далеко не всё, что можно сказать о чистых функциях, но этот базис достаточен для того, чтобы понять суть чистых функций и то, как их можно использовать в своём коде. Продолжение следует…</p>

        <div id="disqus_thread"></div><!-- /#disqus_thread -->
      </div><!-- /.entry-content -->
    </div><!-- /.entry-wrapper -->
    <nav class="pagination" role="navigation">
      
        <a href="http://blog.dshevchenko.biz/2013/12/20/haskell-lambda-functions.html" class="btn" title="Haskell: о лямбда-функциях">Предыдущий</a>
      
      
        <a href="http://blog.dshevchenko.biz/2013/12/23/haskell-hackage.html" class="btn" title="Haskell: устанавливаем пакет из Hackage">Следующий</a>
      
    </nav><!-- /.pagination -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2011-2014 Денис Шевченко. Сайт работает на <a href="http://jekyllrb.com">Jekyll</a> с использованием <a href="http://mademistakes.com/so-simple/">So Simple Theme</a>.</span>
<div class="social-icons">
	<a href="http://twitter.com/dshevchenko_biz" title="В Twitter" target="_blank"><i class="icon-twitter icon-2x"></i></a>
	<a href="http://facebook.com/dshevchenko.biz" title="На Facebook" target="_blank"><i class="icon-facebook icon-2x"></i></a>
	<a href="https://google.com/+DenisShevchenko" title="На Google+" target="_blank"><i class="icon-google-plus icon-2x"></i></a>
	<a href="http://linkedin.com/in/dshevchenkobiz" title="И в LinkedIn я тоже есть" target="_blank"><i class="icon-linkedin icon-2x"></i></a>
	<a href="http://stackexchange.com/users/131381/denis-shevchenko" title="И даже на StackExchange я есть" target="_blank"><i class="icon-stackexchange icon-2x"></i></a>
	
	
	<a href="http://github.com/denisshevchenko" title="И конечно же на Github" target="_blank"><i class="icon-github icon-2x"></i></a>
	
</div><!-- /.social-icons -->

  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://blog.dshevchenko.biz/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://blog.dshevchenko.biz/assets/js/scripts.min.js"></script>

<!-- Jekyll Simple Search option -->
<script>
  $(document).ready(function() {
      $('.search-field').simpleJekyllSearch({
          jsonFile : 'http://blog.dshevchenko.biz/search.json',
          searchResults : '.search-results',
          template : '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
          noResults: '<p>Nothing found.</p>'
        });
  });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $(".icon-remove-sign"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'dshevchenko'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>	        

</body>
</html>
