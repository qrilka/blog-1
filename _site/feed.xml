<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Мысли вслух</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://blog.dshevchenko.biz/feed.xml" />
<link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/" />
<updated>2014-05-15T21:30:29+04:00</updated>
<id>http://blog.dshevchenko.biz/</id>
<author>
  <name>Денис Шевченко</name>
  <uri>http://blog.dshevchenko.biz/</uri>
  <email>me@dshevchenko.biz</email>
</author>


<entry>
  <title type="html"><![CDATA[Поваренная книга Haskell: начало положено]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/5/15/haskell-cookbook.html"/>
  <id>http://blog.dshevchenko.biz/2014/5/15/haskell-cookbook</id>
  <published>2014-05-15T00:00:00+04:00</published>
  <updated>2014-05-15T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Приветствую, друзья!&lt;/p&gt;

&lt;p&gt;Рад сообщить, что поваренная книга Haskell открыта. Строго говоря, некоторые из вас об этом уже знают, поскольку &lt;a href=&quot;http://cookbook.dshevchenko.biz/&quot;&gt;ссылка&lt;/a&gt; на неё висит на главной странице уже почти неделю.&lt;/p&gt;

&lt;p&gt;В своё время мне очень помогла полезная книжка по C++, называется “C++. Сборник рецептов”. Кому интересно - &lt;a href=&quot;http://www.booksgid.com/programmer/36636-c.-sbornik-receptov.html&quot;&gt;вот она&lt;/a&gt;. В ней собраны готовые рецепты для решения многих повседневных задач, стоящих перед C++-разработчиком.&lt;/p&gt;

&lt;p&gt;Именно это я хочу сделать по отношению к Haskell. У каждого программиста, решившего попробовать этот язык в деле, обязательно будут возникать вопросы, мол, “а как в Haskell сделать вот это?”… А если есть вопросы - должны быть и ответы. Да, они есть на Stackoverflow, но, во-первых, они разбросаны, во-вторых, не всегда корректны, а в-третьих, зачастую неполны. Например, верный код приведён, а какие пакеты нужно установить для его работы и какие модули требуются - об этом ни слова.&lt;/p&gt;

&lt;p&gt;Именно поэтому я решил создать каталог готовых и простых Haskell-рецептов для решения обыденных задач. Да, пока их мало, но потом будет значительно больше.&lt;/p&gt;

&lt;p&gt;Собственно, &lt;a href=&quot;http://cookbook.dshevchenko.biz&quot;&gt;вот книга&lt;/a&gt;. Оформлена в виде блога, я счёл это удобным. Замечания и пожелания приветствуются.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/5/15/haskell-cookbook.html&quot;&gt;Поваренная книга Haskell: начало положено&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, май 15, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[В защиту Haskell: по следам одного Хабра-спора...]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/5/11/haskell-discussion.html"/>
  <id>http://blog.dshevchenko.biz/2014/5/11/haskell-discussion</id>
  <published>2014-05-11T00:00:00+04:00</published>
  <updated>2014-05-11T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;На бескрайних просторах Хабра встретилась мне одна &lt;a href=&quot;http://habrahabr.ru/post/133277/&quot;&gt;любопытнейшая тема&lt;/a&gt;. Она довольно стара (ноябрь 2011 года), но это не делает её менее интересной. И интересна она не только тем, что предельно понятным языком объясняет суть теории категорий (да-да, того самого “страшного” математического раздела, из которого вышли понятия монады, моноида и иже с ними), но и тем, что в комментариях к этой теме завязалась примечательная дискуссия. На самом деле, дискуссия там весьма обширна, но меня зацепили комментарии одного пользователя, некоего Бахтерева Михаила Олеговича (зарегистрированного под ником &lt;code&gt;mikhanoid&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Вот с чего всё началось:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Эх. Вот было бы ещё в Haskell так же просто байтик по адресу 0xb8000 записать, цены бы ему не было. А так. Ну да, математика, на да, формально, ну да, можно мозг поупражнять. А дальше? А ведь не особо опытные менджеры уже начинают пытаться внедрять Haskell в production. Ужас. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Затравка цепляет. Ему совершенно справедливо отвечают, мол, не все задачи сводятся к «записать байтик». На что он говорит:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В разработке software — все. Как бы всё равно никому ещё не удалось разработать не-фон-Неймановский универсальный процессор. А там запись байтиков направо и налево :) И вот нам говорят: машина работает одним способом, но нет, мы не будем придумывать язык, который позволит естественное для машины поведение программировать наиболее естественным образом. Мы, наоборот, абстрагируемся, а потом будем ковыряться левой пяткой в правом ухе для решения простейших задач. Не понимаю я, к чему это?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Выходит, абстрагирование от архитектуры процессора вынуждает нас ковыряться левой пяткой в правом ухе для решения простейших задач… Довод из прошлого тысячелетия, но ладно уж, продолжим:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Дело не собственно в памяти. Чтобы организовать обмен данными с внешним миром, нам нужно иметь канал связи с этим миром. А канал связи — это система, у которой нужно явно менять состояния. Если мы рассматриваем сам Haskell (ну, или любой чистый функциональный язык), то там нет такой концепции. Нельзя изменить состояние канала, можно только лишь создать новый канал. Но как внешний мир может узнать об изменении канала связи?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Вот в чём проблема. В Haskell, конечно, есть и указатели, и ссылки, и IO, но их невозможно запрограммировать на самом Haskell, поэтому они создаются искусственно, через специальные монады связанные со внешними библиотеками на Си. И эти монады отличаются от тех, которые можно создать на самом Haskell.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;И ещё:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Так это и есть философская проблема. Скажем, для Си или даже, допустим, Lua, вывод на консоль может быть написан на самих Си или Lua. А чистый функциональный язык уже не допускает этого.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;И тут нельзя сказать, что это просто консоль неправильная, не функциональная, потому что не может быть функциональной консоли.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;И вывод:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Поэтому нельзя на функциональном языке выразить работу с оборудованием и внешним миром. Нужны всякие костыли разной степени костыльности. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Вот такие доводы. К слову, этот Михаил Олегович - человек очень опытный, достаточно взглянуть на его темы на Хабре. Разумеется, вступать с таким человеком в дискуссию на его уровне я бы не стал, ибо занимаюсь задачами куда как менее сложными, чем он. Поэтому выскажу своё мнение как практик. &lt;/p&gt;

&lt;p&gt;Рассмотрим вот такую строку:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;/Users/dshevchenko/text&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Содержимое файла &lt;code&gt;/Users/dshevchenko/text&lt;/code&gt; выводится на консоль. Вы представляете себе, сколько различных программных действий совершается от момента запуска такого кода до момента отображения текста файла в терминале? Их очень много, начиная от вызовов библиотечных функций и заканчивая работой ряда драйверов. И если бы мы очень захотели, то могли бы перечислить все эти действия. Только нужно ли нам это? Нет, нам нужно вывести содержимоей файла на консоль. И такой код прекрасно справляется с этой задачей. &lt;/p&gt;

&lt;p&gt;К чему это я… Михаил Олегович совершенно справедливо отмечает, что на Haskell &lt;em&gt;как таковом&lt;/em&gt; нельзя напрямую взаимодействовать с адресами байтов, и поэтому, разумееется, вывод на консоль не может быть написан на чисто функциональном языке. Однако, насколько я понял тон Михаила Олеговича, он ставит сей факт в укор чисто функциональному подходу как таковому. Мол, раз на нём нельзя явно изменять состояние областей памяти, значит этот язык пригоден исключительно для теоретически-академических целей, а места в real world ему нету…&lt;/p&gt;

&lt;p&gt;И вот сижу я и думаю - а почему, собственно, это такая проблема? Понятно, что где-то под капотом Haskell есть системные функции, написанные на старом добром C, и именно эти функции выполняют всю низкоуровневую работу. Но мне-то зачем об этом знать? Я, как программист-практик, знать этого не хочу, да и не обязан. Разумеется, в процессе выполненения кода, выводящего текст на консоль, происходит многократное изменение различных программных состояний, но мне до этого нет никакого дела. Если всё это под капотом, пусть там и остаётся, а я лучше буду думать о моих задачах, а не о том, как там байтики записываются.&lt;/p&gt;

&lt;p&gt;И я считаю, это очень хорошо и правильно, что вся низкоуровневая работа делегируется коду, написанному на языке C. Вы что думаете, в том же C++ память выделяется оператором &lt;code&gt;new&lt;/code&gt;? Нет, она выделяется старой доброй &lt;code&gt;malloc&lt;/code&gt;, а &lt;code&gt;new&lt;/code&gt; есть не более чем удобный синтаксический сахар. Значит ли это, что мы не должны пользоваться оператором &lt;code&gt;new&lt;/code&gt;? Едва ли…&lt;/p&gt;

&lt;p&gt;Так что в наших процессорах байтики пусть записываются направо и налево, а мы, живущие в 2014 году, позволим себе думать уже не о байтиках, а о других вещах.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/5/11/haskell-discussion.html&quot;&gt;В защиту Haskell: по следам одного Хабра-спора...&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, май 11, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Открыл исходники - открой и планы: waffle.io]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/29/waffle-io.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/29/waffle-io</id>
  <published>2014-04-29T00:00:00+04:00</published>
  <updated>2014-04-29T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Очень и очень понравился мне один &lt;a href=&quot;https://waffle.io/&quot;&gt;сервис&lt;/a&gt;, привязанный к GitHub. До того понравился, что появилась &lt;a href=&quot;http://habrahabr.ru/post/221211/&quot;&gt;новая статья на Хабре&lt;/a&gt;. Рекомендую к ознакомлению, сервис и правда очень полезен и удобен.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/29/waffle-io.html&quot;&gt;Открыл исходники - открой и планы: waffle.io&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 29, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[EaxCast: поддержим проект вместе]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/28/eaxcast-campaign.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/28/eaxcast-campaign</id>
  <published>2014-04-28T00:00:00+04:00</published>
  <updated>2014-04-28T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Не так давно была запущена кампаня по сбору средств для текстовой расшифровки 2-го сезона IT-подкаста EaxCast. Я с удовольствием слушаю этот подкаст, потому что в нём есть действительно полезные вещи.&lt;/p&gt;

&lt;p&gt;Итак, до конца сбора денег осталось две недели, так что вы ещё успеете. Поможем хорошему начинанию, оно того заслуживает.&lt;/p&gt;

&lt;p&gt;Всем заинтересовавшимся просьба следовать &lt;a href=&quot;https://boomstarter.ru/projects/120343/tekstovaya_rasshifrovka_2-go_sezona_it-podkasta_eaxcast&quot;&gt;сюда&lt;/a&gt;.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/28/eaxcast-campaign.html&quot;&gt;EaxCast: поддержим проект вместе&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 28, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О бумажной книге: мысли и сомнения]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/27/paper-book-thoughts.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/27/paper-book-thoughts</id>
  <published>2014-04-27T00:00:00+04:00</published>
  <updated>2014-04-27T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Доброе время суток, друзья!&lt;/p&gt;

&lt;p&gt;Прежде всего, я хочу ещё раз поблагодарить всех читателей моей книги. Для меня нет большей радости, чем видеть ваши отзывы и понимать, что мой труд не пропадает даром.&lt;/p&gt;

&lt;p&gt;Сегодня я хочу развёрнуто ответить на вопрос, уже многократно заданный мне на различных форумах, блогах и в личных письмах. Вопрос о бумажном издании книги “О Haskell по-человечески”. Я ответил на него одному человеку, потом второму, потом третьему, а потом понял, что вопрос этот будет повторяться, поэтому лучше ответить подробно и один раз для всех.&lt;/p&gt;

&lt;p&gt;Итак, что же с этой бумагой?.. Признаюсь, к бумажной книге у меня отношение уважительное. И несмотря на то, что эпоха бумажных IT-книг уже идёт к своему закату, до окончательной смерти этой эпохи ещё далековато. Многие разработчики всё ещё предпочитают бумагу, и я их понимаю: на моих полках тоже много бумажных книг по нашей профессии. И скажу вам честно: я хотел бы видеть мою книгу на полках книжных магазинов, а некоторым людям я хотел бы подарить её, что называется, с автографом.&lt;/p&gt;

&lt;p&gt;Ну, казалось бы, в чём же дело? Ведь есть целый ряд известных издательств, в той или иной степени ориентированных на компьютерную литературу. Это и &lt;a href=&quot;http://www.piter.com/&quot;&gt;Питер&lt;/a&gt;, и &lt;a href=&quot;http://www.symbol.ru/&quot;&gt;Символ-Плюс&lt;/a&gt;, и &lt;a href=&quot;http://www.williamspublishing.com/&quot;&gt;Вильямс&lt;/a&gt;, и &lt;a href=&quot;http://www.nit.com.ru/&quot;&gt;НиТ&lt;/a&gt;, и &lt;a href=&quot;http://dmkpress.com/&quot;&gt;ДМК Пресс&lt;/a&gt;, и ещё с десяток других. И они скорее всего ищут новых авторов (в конце концов, не за счёт ли авторов они и живут?). И всё же есть что-то, что меня останавливает…&lt;/p&gt;

&lt;p&gt;У бумажного книгоиздательства, несомненно, есть ряд плюсов. Во-первых, многие привыкли к физическим книгам, и готовы платить за них, причём зачастую больше, чем могли бы заплатить за электронный вариант. Во-вторых, бумажную книгу можно подарить, ведь многие (включая меня) твёрдо убеждены в том, что книга - это прекрасный подарок. В-третьих, не у всех есть электронные читалки, а читать с экрана опять-таки любят не все. И однако, при всех плюсах, имеется и несколько серьёзных минусов. О них и пойдёт речь далее.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Минус номер раз - статичность&lt;/h3&gt;

&lt;p&gt;Как только бумажная книга издана - всё, на какое-то время она замерла. Как говорится, что написано пером, того не вырубишь топором. Электронный вариант, напротив, предельно динамичен и гибок. Исправить ошибку в тексте? Улучшить пример кода? Что-то дополнить/убрать/переписать? Внёс изменения в &lt;code&gt;.md&lt;/code&gt;-файлы, коммит-пуш - и готово, все читатели уже читают улучшенный вариант. Да, в бумажном книгоиздании существует понятие “Издание 2, исправленное и переработанное”, но это происходит не так быстро, как хотелось бы автору…&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Минус номер два - опыт&lt;/h3&gt;

&lt;p&gt;Многие издательства, при передачи им рукописи, спрашивают автора о его опыте в рассматриваемой им области. И вот представьте себе такой диалог:&lt;/p&gt;

&lt;p&gt;&lt;span&gt;-&lt;/span&gt; Здравствуйте! Меня зовут Денис, я написал книгу о языке Haskell, хочу издаваться.&lt;br /&gt;
&lt;span&gt;-&lt;/span&gt; Прекрасно. А каков ваш опыт в данной тематике? Вы доцент кафедры информатики в МФТИ? Или, может, вы реализовали на Haskell пяток серьёзных проектов?&lt;br /&gt;
&lt;span&gt;-&lt;/span&gt; Нет, совсем не доцент и пока ничего не реализовал, только собираюсь.&lt;br /&gt;
&lt;span&gt;-&lt;/span&gt; Как это ничего не реализовали? Так вы что же, самоучка??&lt;br /&gt;
&lt;span&gt;-&lt;/span&gt; Да, я самоучка, но многих разработчиков моя книга заинтересовала, вот я и подумал, что…&lt;br /&gt;
&lt;span&gt;-&lt;/span&gt; Простите, молодой человек, мы вынуждены вам отказать. Мы - авторитетное издательство и не можем позволить себе издавать творения дилетантов-выскочек. До свидания!&lt;/p&gt;

&lt;p&gt;Я немного утрирую, но во многих издательствах мне примерно так и ответят. И едва ли их заинтересуют мои доводы о том, что многие читатели присылали мне восторженные отзывы и признавались, что более понятной книги о Haskell им видеть не доводилось. К сожалению, статус зачастую важнее сути.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;Минус номер три - территория&lt;/h3&gt;

&lt;p&gt;Допустим, книгу издадут. Но её тираж едва ли превысит 2000 экземпляров. Следовательно, до многих городов нашей необъятной родины книга не дойдёт. Но программисты, интересующиеся Haskell, живут не только в Москве или Питере, они живут и в относительной глубинке. Если книга будет бумажной - пойди-ка найди её! Если же останется электронной - любой подключенный к Интернету сможет её прочесть.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;Минус номер четыре - права&lt;/h3&gt;

&lt;p&gt;Этот минус - самый главный, самый весомый. Настолько весомый, что даже перекрывает собою предыдущие три минуса. Речь идёт об исключительных правах, передаваемых издательству автором. Большинство издательств, заключая с автором так называемый “авторский договор”, требует от автора передачи исключительных прав на текст. И чтобы было понятно, что это означает, приведу выдержку из авторского договора одного известного российского издательства:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;С момента одобрения Издательством созданного в рамках Договора Произведения, Автор предоставляет Издательству в объеме и на условиях, предусмотренных Договором, на условиях исключительной лицензии права на использование Произведения Издательством…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… предоставленная в соответствии с данным Договором исключительная лицензия … означает исключительное и преимущественное право Издательства перед любыми лицами, включая Автора, осуществлять самостоятельно, разрешать осуществлять и запрещать осуществлять любым лицам, включая Автора, использование перечисленными способами Произведения как полностью, так и в любой части, а равно в любом дополненном и (или) переработанном виде, как в отдельности, так и путем объединения с любой иной информацией независимо от формы и способа ее выражения, вносить в Произведение изменения, сокращения и дополнения, снабжать Произведение при его использовании иллюстрациями, предисловием, послесловием, комментариями или какими бы то ни было пояснениями, на территории всех стран и государств мира в течение 10 (десяти) лет с момента одобрения Произведения Издательством.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Перевожу на нормальный язык: как только мою книгу решат издавать, права на её текст перейдут издательству, и в течение следующих 10 лет только издательство будет решать, когда, как и где сия книга будет опубликована и что будет с её текстом. Не всегда речь идёт именно о 10 годах, бывает и меньше, но суть не в этом. Суть в том, что такое требование - это огромный минус для меня. А чтобы вы поняли, почему, я буду с вами предельно откровенен.&lt;/p&gt;

&lt;p&gt;Почему я решил написать про Haskell? Потому что решил заработать? Смешно: учитывая авторские отчисления от каждого проданного экземпляра и предполагаемый объём первого тиража, я получу сумму, ощутимо уступающую моей месячной зарплате. И это при идеальных условиях, то есть если:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;авторские отчисления будут относительно щедрыми (процентов эдак двенадцать от закупочной цены),&lt;/li&gt;
  &lt;li&gt;весь тираж будет распродан (то есть в идеале 2 тысячи экземпляров),&lt;/li&gt;
  &lt;li&gt;издательство меня не кинет.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Значит, причина точно не в деньгах. Тогда, может, в том, чтобы прославиться? Ещё смешнее: книга столь специфической тематики никогда не будет продаваться стотысячными тиражами.&lt;/p&gt;

&lt;p&gt;Причина одна - я намерен внести вклад в сообщество и открыть моим коллегам удивительный мир функционального программирования. И скажу вам честно, моё намерение не осталось бесплодным: многие читатели написали мне, что благодаря моей книге они наконец-то поняли, что ФП - это нечто действительно реальное и полезное. Значит, дилетант вроде меня всё-таки смог донести до читателей красоту Haskell. К тому же, как уже знают многие из вас, я задумал не только развивать первый том книги, но и писать второй, и многие уже ждут его.&lt;/p&gt;

&lt;p&gt;И вот на всём этом будет поставлен жирный крест, если я заключу договор исключительной лицензии. Сразу же после заключения такого договора я буду вынужден удалить &lt;a href=&quot;https://github.com/denisshevchenko/ohaskell&quot;&gt;репозиторий&lt;/a&gt; книги, её &lt;a href=&quot;http://ohaskell.dshevchenko.biz/&quot;&gt;GitHub-страницу&lt;/a&gt;, а также все её электронные копии, уже сохранённые на нескольких сайтах. Кроме того, я уже не смогу вносить в книгу правки и дополнения, я смогу лишь вежливо попросить об этом редактора, а он единолично решит, стоит ли их вносить и когда будет переиздание. Причём, что самое неприятное, срок действия всех этих ограничений останется неизменным даже в том случае, если продажи первого тиража провалятся. То есть неважно, как будет продаваться твоя книга - раз заключил договор, будь добр на N лет подарить её издательству.&lt;/p&gt;

&lt;p&gt;Я не стану давать оценку подобным ограничениям типичного авторского договора. Хороши они или плохи - судить не мне. В конце концов, издательство тоже можно понять: ему нужно максимально подстраховаться, ибо его в первую очередь интересует финансовый успех книги, а не “вклад в русскоязычное IT-сообщество”.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;Выводы?&lt;/h3&gt;

&lt;p&gt;Выводов чётких нет. С одной стороны, есть плюсы, с другой - серьёзные минусы. Поэтому я спрашиваю вас: что вы обо всём этом думаете? Буду рад любым мнениям и рекомендациям.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/27/paper-book-thoughts.html&quot;&gt;О бумажной книге: мысли и сомнения&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 27, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[От динамики к статике: прощай, Drupal...]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/22/goodbye-drupal.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/22/goodbye-drupal</id>
  <published>2014-04-22T00:00:00+04:00</published>
  <updated>2014-04-22T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Да, решение принято, и обжалованию уже не подлежит: Drupal уходит из моей профессиональной жизни. Четыре года я использовал эту прекрасную CMS, но теперь пришла пора попрощаться. Я окончательно убедился в том, что для моих сайтов Drupal не нужен.&lt;/p&gt;

&lt;p&gt;В процессе настройки GitHub-страницы для книги я узнал о &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Сказать, что меня зацепило - это не сказать ничего! Слияние GitHub и Markdown - это реально круто. Ну а поскольку второй том моей книги будет написан на Markdown и жить будет также на GitHub, мне будет вдвойне удобнее.&lt;/p&gt;

&lt;p&gt;Больше никаких админок, никаких БД, никаких бэкапов, паролей, обновлений и FTP. Только Vim, Markdown и Git. Добавил &lt;code&gt;.md&lt;/code&gt;-файл, затем &lt;code&gt;jekyll build&lt;/code&gt;, коммит-пуш - и новая запись уже в блоге. А блог, надо сказать, получился знатным. Во-первых, офигительно быстрым. Во-вторых, мобильно-адаптивным из коробки (на iPhone читается великолепно). В-третьих, красивым и удобным (спасибо &lt;a href=&quot;http://mademistakes.com/about/&quot;&gt;Michael Rose&lt;/a&gt; и его прекрасной &lt;a href=&quot;http://mademistakes.com/articles/so-simple-jekyll-theme/&quot;&gt;So Simple Theme&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;В общем, я доволен как слон. К тому же Jekyll позволил мне довольно безболезненно импортировать сюда всё содержимое старого блога. Да, пути стали другими, но Поиск по блогу - просто отменный.&lt;/p&gt;

&lt;p&gt;Да, от пользовательских аккаунтов я тоже отказался. Всё-таки для комментариев достаточно Disqus (который, кстати, тоже был прикручен к данному блогу прямо из коробки). К тому же удобно: даже если нет социальных профилей, один раз зарегистрировался на &lt;a href=&quot;http://disqus.com/&quot;&gt;Disqus&lt;/a&gt; - и можешь комментировать 100500 разных блогов.&lt;/p&gt;

&lt;p&gt;И ещё… В название поста сказано “от динамики к статике”. Это мне так по душе, ведь Haskell статичен… ;-)&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/22/goodbye-drupal.html&quot;&gt;От динамики к статике: прощай, Drupal...&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 22, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О Haskell по-человечески: уже онлайн]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/14/ohaskell-online.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/14/ohaskell-online</id>
  <published>2014-04-14T00:00:00+04:00</published>
  <updated>2014-04-14T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Приветствую, друзья!&lt;/p&gt;

&lt;p&gt;Рад сообщить, что моя книга теперь уютно живёт &lt;strong&gt;&lt;a href=&quot;http://ohaskell.ru/fst&quot;&gt;онлайн&lt;/a&gt;&lt;/strong&gt;. Я чуток подкорректировал &lt;strong&gt;&lt;a href=&quot;https://github.com/GitbookIO/gitbook/tree/master/theme&quot;&gt;умолчальную тему&lt;/a&gt;&lt;/strong&gt;, убрав из неё всё лишнее. Получилось лаконично, симпатично и мобильно-адаптивно.&lt;/p&gt;

&lt;p&gt;Многие читатели просили меня об этом, и наконец решение принято: теперь книга существует в формате Markdown &lt;strong&gt;&lt;a href=&quot;https://github.com/denisshevchenko/ohaskell&quot;&gt;в своём репозитории&lt;/a&gt;&lt;/strong&gt;. Все остальные форматы книги также будут создаваться из Markdown-файлов, так будет удобнее всем. Мне очень понравился формат Markdown, поэтому и второй том книги будет написан в нём.&lt;/p&gt;

&lt;p&gt;Кстати, о втором томе… Началась работа над маленьким проектом, описание которого ляжет в основу этого тома. Впрочем, работа над первым томом не завершена: он ещё будет дополнен и улучшен. Ждите новостей.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/14/ohaskell-online.html&quot;&gt;О Haskell по-человечески: уже онлайн&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 14, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[GitBook: как я строил веб-книгу]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/7/gitbook.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/7/gitbook</id>
  <published>2014-04-07T00:00:00+04:00</published>
  <updated>2014-04-07T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Многие из читателей пожелали видеть HTML-версию моей книги. Думал я, думал - и наткнулся на прекрасный инструмент &lt;strong&gt;&lt;a href=&quot;http://www.gitbook.io/&quot;&gt;GitBook&lt;/a&gt;&lt;/strong&gt;. А что из этого вышло - читайте здесь: http://habrahabr.ru/post/218433.&lt;/p&gt;

&lt;p&gt;Скоро вся книга будет доступна тут: http://denisshevchenko.github.io/ohaskell/index.html.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/7/gitbook.html&quot;&gt;GitBook: как я строил веб-книгу&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 07, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О Haskell по-человечески: четвёртое издание]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/4/1/ohaskell-fourth-edition.html"/>
  <id>http://blog.dshevchenko.biz/2014/4/1/ohaskell-fourth-edition</id>
  <published>2014-04-01T00:00:00+04:00</published>
  <updated>2014-04-01T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Итак, сегодня вышло в свет издание 0.4. Нет, это не первоапрельская шутка. Из новшеств:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Глава про интеграцию Haskell с языком C.&lt;/li&gt;
  &lt;li&gt;Корректировка PDF: новый шрифт, улучшенная структура.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Изучение просторов Stackoverflow убедительно доказало мне, что многих разработчиков интересует тема интеграции Haskell-приложения с модулями, написанными на иных языках. Но, когда я сам стал изучать эту тему, то выяснилось, что нормальных, пошаговых и понятных с &lt;em&gt;первого&lt;/em&gt; прочтения материалов по этому вопросу нет (впрочем, возможно я плохо искал). Именно поэтому в книгу добавлена глава про прикручивание C-функций к Haskell.&lt;/p&gt;

&lt;p&gt;Ну и по поводу PDF. Читатели обращались ко мне с жалобами, что со шрифтом, используемым в предыдущих изданиях, у них были проблемы. В частности, в Adobe Reader на Windows 7 некоторые буквы отображались криво, ну а в Firefox на Windows 7 - там вообще была плохочитаемый текст. Теперь всё выглядит значительно красивее: я нашёл прекрасный, неизбитый шрифт “Пермиан” (http://pcrd.ru/projects/167).&lt;/p&gt;

&lt;p&gt;Так что обновляйтесь, друзья: http://ohaskell.ru/&lt;/p&gt;

&lt;p&gt;P.S. К следующему изданию всё-таки доберусь до монадных трансформеров…&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/4/1/ohaskell-fourth-edition.html&quot;&gt;О Haskell по-человечески: четвёртое издание&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, апрель 01, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О Haskell по-человечески и по-английски!]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/3/17/ohaskell-translation.html"/>
  <id>http://blog.dshevchenko.biz/2014/3/17/ohaskell-translation</id>
  <published>2014-03-17T00:00:00+04:00</published>
  <updated>2014-03-17T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Я в шоке, друзья!&lt;/p&gt;

&lt;p&gt;Вчера решил ради прикола опубликовать новость о третьем издании моей книги на Reddit. Ну, опубликовал в Haskell-группе. (http://redd.it/20k2we). Но, поскольку Reddit - это англоязычное сообщество, я не думал, что будет большой интерес к моей новости, тем более что опубликована она была по-русски.&lt;/p&gt;

&lt;p&gt;И тут мне пишут в комментарии, мол, а английский перевод вашей книги будет? Признаюсь, такого вопроса я точно не ожидал. А один из пользователей написал мне письмо, в котором также высказал идею о переводе. Я отвечаю, мол, спасибо на добром слове, но едва ли моя книга сможет соперничать с этой книгой: “Beginning Haskell, A Project-Based Approach”, http://www.apress.com/9781430262503. А он мне отвечает, мол, ваша книги лучше, потому что в ней нет “воды” и всё по делу.&lt;/p&gt;

&lt;p&gt;А сегодня я зашёл в обсуждение на Reddit, посмотреть последние комментарии, и чуть со стула не упал: пока я спал, один разработчик Jack Henahan, из университета в Вермонте, создал GitHub-репозиторий для группового английского перевода моей книги! Я даже глазам не поверил, но потом зашёл - и правда: https://github.com/jhenahan/ohaskell-translations.&lt;/p&gt;

&lt;p&gt;Признаться, к интересу со стороны моих англоязычных коллег я не был готов. Но раз он появился - я, разумеется, подключусь к переводу. Это будет классный проект!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/3/17/ohaskell-translation.html&quot;&gt;О Haskell по-человечески и по-английски!&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, март 17, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О Haskell по-человечески: первое издание]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/3/5/ohaskell-first-edition.html"/>
  <id>http://blog.dshevchenko.biz/2014/3/5/ohaskell-first-edition</id>
  <published>2014-03-05T00:00:00+04:00</published>
  <updated>2014-03-05T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Готово! Первое издание моей скромной книги о Haskell вышло в свет.&lt;/p&gt;

&lt;p&gt;Живёт оно тут: http://ohaskell.ru.&lt;/p&gt;

&lt;p&gt;Прямая ссылка: http://ohaskell.ru/get/ohaskell.pdf.&lt;/p&gt;

&lt;p&gt;Распространение книги в любой форме - приветствуется!&lt;/p&gt;

&lt;p&gt;Любые отзывы о книге, вопросы, предложения, а также разгромную критику присылайте прямиком на мою почту: me@dshevchenko.biz. Или прямо сюда, в комментариях. &lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/3/5/ohaskell-first-edition.html&quot;&gt;О Haskell по-человечески: первое издание&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, март 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[О геттерах и сеттерах]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/2/27/getters-and-setters.html"/>
  <id>http://blog.dshevchenko.biz/2014/2/27/getters-and-setters</id>
  <published>2014-02-27T00:00:00+04:00</published>
  <updated>2014-02-27T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Итак, есть у нас следующий код:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Перед нами - канонические геттер и сеттер. Первый &lt;em&gt;просто&lt;/em&gt; возвращает значение идентификатора рабочего, второй - &lt;em&gt;просто&lt;/em&gt; устанавливает это значение.&lt;/p&gt;

&lt;p&gt;И вот совсем недавно я со всею остротой понял, сколь бессмысленны канонические геттеры и сеттеры. От них нет абсолютно никакой пользы. Они только усложняют нашу жизнь.&lt;/p&gt;

&lt;p&gt;Сравним:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Суть не изменилась, а код стал короче и проще.&lt;/p&gt;

&lt;p&gt;Зачем мне прятать поле и при этом предоставлять две функции, открывающие доступ к нему? Это бессмысленно. К тому же на каждое поле мне придётся предоставлять по паре геттер-сеттер, и в большинстве случаев это будет два объявления и две реализации. Сравните это:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Где-то в .cpp-шнике&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_section&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;и это:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Фундаментальная проблема канонических геттеров и сеттеров в том, что они раздувают мой код и привносят в него ненужную сложность, при этом ничего не давая мне взамен. А почему же этих геттеров и сеттеров полно в 99% всех C++-проектов? Виной тому - маниакальная страсть закрывать поля просто потому, что “в соответствии с принципом инкапсуляции данные должны быть сокрыты”.&lt;/p&gt;

&lt;p&gt;Должны быть сокрыты? Так скрывай их в pimpl, и будет тебе счастье. А то, видите-ли, объявил со словом &lt;strong&gt;&lt;code&gt;private&lt;/code&gt;&lt;/strong&gt;, но при этом предоставил две функции, сводящие всю эту &lt;strong&gt;&lt;code&gt;private&lt;/code&gt;&lt;/strong&gt;-ность к нулю. И чем это отличается от открытого поля? Ничем. &lt;/p&gt;

&lt;p&gt;Вывод: выкидывайте канонические геттеры и сеттеры. Окончательно и бесповоротно. А поля, к которым необходим &lt;em&gt;простой&lt;/em&gt; read-write доступ извне, просто делайте открытыми.&lt;/p&gt;

&lt;h3&gt;Уточнение&lt;/h3&gt;

&lt;p&gt;Вы заметили, я всё время повторяю слово “канонические”. Речь шла только о таких геттерах и сеттерах, которые &lt;em&gt;просто&lt;/em&gt; возвращают и &lt;em&gt;просто&lt;/em&gt; изменяют. Но при этом я вполне могу оправдать сеттер, который, помимо установки значения, производит некую проверку (и кричит на всю Ивановскую в случае проблем).&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/2/27/getters-and-setters.html&quot;&gt;О геттерах и сеттерах&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, февраль 27, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Об IT-книгах: пара мыслей вслух]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/2/22/it-books.html"/>
  <id>http://blog.dshevchenko.biz/2014/2/22/it-books</id>
  <published>2014-02-22T00:00:00+04:00</published>
  <updated>2014-02-22T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Недавно задумался о книгах… На мой взгляд, электронная книга уже победила бумажную. Люди всё больше привыкают к мысли о том, что книга в виде файла столь же книжная, как и книга в виде бумаги и клея.&lt;/p&gt;

&lt;p&gt;В самом деле, почему бы и нет? Купил электронную читалку - и в ней вся твоя библиотека. Удобное и компактное устройство в высшей степени мобильно. А экраны e-ink просто прекрасны! И никаких тебе книжных шкафов, заставленных устаревшей IT-литературой. Вот у меня сейчас лежит десятка три книг, которые уже беспросветно устарели, и больше не нужны ни мне, ни кому-либо из моих коллег. А выбросить… Да вроде как-то жалко, что ли… А электронную книгу - два клика и нету.&lt;/p&gt;

&lt;p&gt;А цены? Вы их видели? Электронная копия издания как минимум в два раза дешевле бумажной (а то и в три). К тому же, сейчас появилось много мест, где можно легально и быстро купить электронные издания. Ведь издательства тоже держат нос по ветру, поэтому электронный вариант бумажной книги - это уже не исключение, а почти правило.&lt;/p&gt;

&lt;p&gt;И кстати, ещё один фактор есть - экономия бумаги. Не улыбайтесь, эта тема серьёзнее чем думают многие. Почему бы не внести свой крошечный вклад в дело сохранения мировых лесов?&lt;/p&gt;

&lt;p&gt;В общем, электронная книга - это хорошо.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/2/22/it-books.html&quot;&gt;Об IT-книгах: пара мыслей вслух&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, февраль 22, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[После долгого затишья...]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/2/12/after-long-silence.html"/>
  <id>http://blog.dshevchenko.biz/2014/2/12/after-long-silence</id>
  <published>2014-02-12T00:00:00+04:00</published>
  <updated>2014-02-12T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Прошу прощения за длительное безмолвие. Все силы, свободные от основной работы, ушли на написание руководства по языку Haskell. Скоро, очень скоро оно будет готово. &lt;/p&gt;

&lt;p&gt;В процессе его написания я ещё больше убедился в том, что функциональное программирование в целом (и Haskell в частности) - это чрезвычайно интересная штуковина. И даже те аспекты этого языка, которые считаются архисложными и супернепонятными, оказались весьма логичными, удобными и совершенно не сложными.&lt;/p&gt;

&lt;p&gt;Я окончательно увидел &lt;em&gt;ложность&lt;/em&gt; представления о Haskell как о языке сугубо академическом и невероятно трудном в освоении для простых программистов. Скажу прямо: если уж я смог разобраться - значит смогут и многие, многие другие.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/2/12/after-long-silence.html&quot;&gt;После долгого затишья...&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, февраль 12, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Русские буквы в именах: невероятно, но факт]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2014/1/22/russian-letters-in-names.html"/>
  <id>http://blog.dshevchenko.biz/2014/1/22/russian-letters-in-names</id>
  <published>2014-01-22T00:00:00+04:00</published>
  <updated>2014-01-22T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Случайно наткнулся на &lt;strong&gt;&lt;a href=&quot;http://eao197.blogspot.com/2014/01/progcwow-const-int-1.html&quot;&gt;одну заметку&lt;/a&gt;&lt;/strong&gt;, в которой говорится о живом коде на C++, в котором имена некоторых переменных набраны русскими буквами (в кодировке CP1251), и это компилируется!&lt;/p&gt;

&lt;p&gt;Дай, думаю, попробую. Никакого рационального зерна тут нет, просто ради смешного эксперимента… Кодировка у меня UTF-8, но попробовать всё равно захотелось.&lt;/p&gt;

&lt;p&gt;Итак, C++:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;код&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;код&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;К счастью, или к сожалению, сей код не компилируется, и ошибка компиляции вполне ожидаемая:&lt;/p&gt;

&lt;bash&gt;
stray &#39;\320&#39; in program
&lt;/bash&gt;

&lt;p&gt;А теперь, ради эксперимента, попробуем на Haskell:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;err&quot;&gt;больше&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;чем&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;больше&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;чем&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;больше&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;чем&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Вы не поверите, но это компилируется и работает! Не знаю, хорошо это или плохо, но русскоязычное имя функции допустимо, в том числе и в инфиксной форме, как здесь.&lt;/p&gt;

&lt;p&gt;Кроме того, я могу использовать русские буквы в имени типа:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IP_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;адрес&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IP_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;адрес&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;И это тоже работает! А как вам такое:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Строка&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Машина&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;номер&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Строка&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Я чуть со стула не упал! Друзья, я не поверил своим глаза (как, вероятно, не верите и вы), но это работает! Ещё сегодня утром я был бы готов поспорить, что такое невозможно. Но, как видим, и невозможное возможно…&lt;/p&gt;

&lt;p&gt;Впрочем, я надеюсь, вы не рассматриваете эту заметочку как призыв русифицировать свой код. :)&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2014/1/22/russian-letters-in-names.html&quot;&gt;Русские буквы в именах: невероятно, но факт&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, январь 22, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Haskell: идея]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2013/12/29/haskell-idea.html"/>
  <id>http://blog.dshevchenko.biz/2013/12/29/haskell-idea</id>
  <published>2013-12-29T00:00:00+04:00</published>
  <updated>2013-12-29T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;В общем, после долгих размышлений, после первичного восторга от ФП в целом и от Haskell в частности я решил внести свой посильный вклад в популяризацию Haskell среди русскоязычного IT-сообщества.&lt;/p&gt;

&lt;p&gt;На мой взгляд, одним из важных препятствий на пути развития Haskell в России является очень малое количество русскоязычных руководств. Нет, руководства-то имеются, но большая их часть - это те самые, с числами Фибоначчи которые…&lt;/p&gt;

&lt;p&gt;Поэтому я решил не ограничиваться рамками данного блога, а сделать отдельный сайт, посвящённый практическому руководство по языку Haskell. Цель этого руководства - пошаговое, максимально понятное и предельное практичное объяснение сущности языка Haskell и вменяемая демонстрация его реального использования.&lt;/p&gt;

&lt;p&gt;И тот факт, что я, мягко выражаясь, не являюсь доцентом МФТИ, как раз является преимуществом для такой задумки! Потому что если уж я смогу разобраться с этим самым Haskell, то и многие другие тоже смогут. &lt;/p&gt;

&lt;p&gt;Следите за новостями…&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2013/12/29/haskell-idea.html&quot;&gt;Haskell: идея&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, декабрь 29, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Haskell: о функциях высшего порядка]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2013/12/26/haskell-higher-order-functions.html"/>
  <id>http://blog.dshevchenko.biz/2013/12/26/haskell-higher-order-functions</id>
  <published>2013-12-26T00:00:00+04:00</published>
  <updated>2013-12-26T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Функции высшего порядка (higher-order functions) - очень важная и очень интересная особенность языка Haskell. Эта особенность основана на том постулате, что функции в Haskell - это &lt;em&gt;значения&lt;/em&gt;. Знаю, это не так легко укладывается в голове, но такова особенность функционального программирования в целом: функции являются значениями (в широком смысле этого слова). Впрочем, если вы прочитали мою прошлую заметку о чистых функциях, вас это уже не должно удивлять, потому что вы уже знаете. что вызов чистой функции в конечном итоге порождает некоторое конечное выражение (являющееся итогом вычисления всех выражений в теле этой функции), которым компилятор заменяет место вызова.&lt;/p&gt;

&lt;p&gt;А раз уж функции являются значениями, то их можно, во-первых, передавать другим функциям в качестве аргумента, а во-вторых, возвращать из других функций в качестве выходного значения. Так вот функция A, которая принимает некую функцию B в качестве аргумента и/или возвращает некую функцию C в качестве выходного значения, называется &lt;em&gt;функцией высшего порядка&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;А теперь начинаем удивляться...&lt;/h3&gt;

&lt;p&gt;Помните, когда я рассказывал вам о чистых функциях, было упомянуто, что такие функции могут принимать как один, так и множество аргументов. На самом деле, я обманул вас, ибо правда такова:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Функции в Haskell всегда принимают только один аргумент. Ни больше, ни меньше.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Но, простите, а как же мы смогли определить функции, принимающие два аргумента?? Отвечаю: это была хитрость. :)&lt;/p&gt;

&lt;p&gt;Хитрость это называется “каррирование” (currying), иногда говорят “карринг”. Слово это знаменитое, ибо оно происходит от имени &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_Curry&quot;&gt;Haskell Curry&lt;/a&gt;&lt;/strong&gt;. Да-да, этот тот самый американский математик, в честь которого назвали изучаемый нами язык.&lt;/p&gt;

&lt;p&gt;Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую все эти аргументы по одному. Что за ерунда, спросите вы. Поясняю.&lt;/p&gt;

&lt;p&gt;Определим функцию деления двух чисел:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Итак, мы определили функцию, принимающую два значения типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt; и возвращающую результат деления первого на второе. Всё предельно просто, не так ли? На самом деле, не так…&lt;/p&gt;

&lt;p&gt;Если мы посмотрим “пот капот” вызова этой функции:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;то узнаем, что вызов этой функции происходит &lt;em&gt;в два этапа&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Функция &lt;code&gt;divide&lt;/code&gt; применяется к первому аргументу &lt;code&gt;10.03&lt;/code&gt;, вычисляется и возвращает *функцию* типа &lt;code&gt;Double -&amp;gt; Double&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Эта возвращённая функция применяется ко второму аргументу &lt;code&gt;2.1&lt;/code&gt;, вычисляется и возвращает конечное значение 4.776190476190476.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;На самом деле мы могли бы более явно отразить эту “двуэтапность”, переписав вызов так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Понимаете, да? Функция всегда применяется только к одному аргументу: сначала к 10.03, а потом возвращённая первым вызовом функция применяется к 2.1.&lt;/p&gt;

&lt;p&gt;Именно поэтому строка объявления такой функции содержит &lt;em&gt;две&lt;/em&gt; стрелочки вместо одной:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Мы помним, что символ стрелочки говорит нам о функции. Так вот здесь мы видим &lt;em&gt;две&lt;/em&gt; стрелочки именно потому, что вызов этой функции происходит в два этапа. И поэтому, строго говоря, неправильно читать это объявление так:&lt;/p&gt;

&lt;p&gt;“Функция &lt;code&gt;divide&lt;/code&gt; принимает два аргумента типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt; и возвращает значение типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt;.”&lt;/p&gt;

&lt;p&gt;Правильно читать так:&lt;/p&gt;

&lt;p&gt;“Функция &lt;code&gt;divide&lt;/code&gt; принимает первый аргумент типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt; и возвращает функцию типа &lt;strong&gt;&lt;code&gt;Double -&amp;gt; Double&lt;/code&gt;&lt;/strong&gt;, принимающую второй аргумент типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt; и возвращающую значение типа &lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt;.”&lt;/p&gt;

&lt;p&gt;Более того, это правильное прочтение объявления можно было бы отразить явно и в самом объявлении! Вот так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Теперь мы явно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа &lt;strong&gt;&lt;code&gt;Double -&amp;gt; Double&lt;/code&gt;&lt;/strong&gt;, а на втором этапе происходит уже вызов этой (возвращённой на первом этапе) функции.&lt;/p&gt;

&lt;p&gt;По аналогии, если бы у нас была функция, принимающая три аргумента:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;45.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;то её вызов на самом деле проходил бы &lt;em&gt;в три этапа&lt;/em&gt;, и чтобы явно отразить это, мы могли бы переписать её объявление так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;а её вызов - так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;45.7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;А теперь нам нужно уточнить одну важную деталь.&lt;/p&gt;

&lt;h3&gt;Частичное применение функции&lt;/h3&gt;

&lt;p&gt;Вспомните, что я сказал о функции &lt;code&gt;divide&lt;/code&gt;: её вызов происходит &lt;em&gt;в два этапа&lt;/em&gt;. Так вот важно понимать, что функция &lt;code&gt;divide&lt;/code&gt; вызывается &lt;em&gt;один&lt;/em&gt; раз, а не два раза! Вызов один (то есть тело этой функции выполняется единократно), просто этот вызов разделён на два шага. А чтобы понять суть этих шагов, необходимо узнать об одной важной детали: частичное применение функции. Звучит страшновато, но суть очень проста.&lt;/p&gt;

&lt;p&gt;Частичное применение (partial application) функции - это такой её вызов, когда ей на вход подаются не все аргументы, которые она ожидает. И здесь нам пригодятся уже известные нам &lt;strong&gt;&lt;a href=&quot;http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85&quot;&gt;λ-функции&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Представим себе, что наша функция &lt;code&gt;divide&lt;/code&gt; была бы апплицирована (применена) не к двум, а только к одному аргументу. Тогда это выглядело бы так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temporary_function&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- &amp;quot;запомнили&amp;quot; первый&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temporary_function&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- получили второй!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Вот теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает вызов вида:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В результате первого вызова, когда мы применили функцию &lt;code&gt;divide&lt;/code&gt; лишь к одному (первому) аргументу, мы ещё не можем получить результат деления, потому что второго-то аргумента мы функции ещё не дали! Вместо этого мы получили как бы временную (промежуточную) λ-функцию, которую мы для наглядности ассоциировали с выражением &lt;code&gt;temporary_function&lt;/code&gt;. Эта временная λ-функция как бы запомнила значение первого аргумента, и когда мы применили её уже ко второму аргументу, то в результате мы уже получили итоговый результат деления.&lt;/p&gt;

&lt;p&gt;По аналогии, вызов нашей функции &lt;code&gt;total_sum&lt;/code&gt;, который, как мы помним, происходит в три этапа, можно разложить так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_function&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_sum&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- &amp;quot;запомнили&amp;quot; первый&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;second_function&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_function&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- &amp;quot;запомнили&amp;quot; второй&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_function&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- получили третий!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;То есть в процессе вызова у нас появилось уже две промежуточные λ-функции, каждая из которых принимала лишь один аргумент и как бы запоминала его. И только тогда, когда вторая промежуточная λ-функция была апплицирована к третьему аргументу (который и оказался последним необходимым для нас), мы и получаем итоговую сумму.&lt;/p&gt;

&lt;p&gt;Разумеется, на практике вводить такие промежуточные λ-функции вам не придётся. Я лишь показал процесс каррирования на практике. Считайте, что мы просто заглянули “под капот” функции и увидели её внутреннюю “пошаговость”.&lt;/p&gt;

&lt;h3&gt;&quot;Ну хорошо, а зачем всё это нужно??&quot;&lt;/h3&gt;

&lt;p&gt;Резонный вопрос. На самом деле, в подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении к аргументам &lt;em&gt;не нужно&lt;/em&gt;. Главное преимущество такого подхода, при котором одна функция от нескольких аргументов раскладывается на цепочку функций от одного аргумента каждая, лежит в “академическом измерении”: проводить формальные математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и выдаёт строго одно значение.&lt;/p&gt;

&lt;p&gt;Но нас-то с вами, как программистов-практиков, гораздо больше интересует аспект практический, а не академический. И поэтому теперь мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).&lt;/p&gt;

&lt;p&gt;Формально функции &lt;code&gt;divide&lt;/code&gt; и &lt;code&gt;total_sum&lt;/code&gt; являются ФВП, в силу тех самых промежуточных λ-функций. Фактически, все функции, объявленные как принимающие более одного аргумента, являются ФВП. Но на самом деле все эти промежуточные λ-функции - это всего лишь подкапотные дела, они скрыты от наших глаз, в то время как гораздо больший интерес представляют “настоящие” ФВП, которые характеризуются именно тем, что явно объявлены как принимающие на вход реальные функциональные значения и/или возвращающие реальные функциональные значения.&lt;/p&gt;

&lt;p&gt;А чтобы разобраться в том, как всё это работает на практике, и понять реальную пользу от ФВП, давайте разберём небольшой пример.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;user_info&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;user_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;login&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar_URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;Full info about user @&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; login: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;login&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; password: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; avatar URL: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar_URL&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EmptyInfo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WithLogin&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithPassword&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithAvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;store_login_in&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EmptyInfo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WithLogin&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;store_login_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;empty_info&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;denis&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- В реальности логин будет получен &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- в соответствии с переданным user_id&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;store_password_in&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WithLogin&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithPassword&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;store_password_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;123456789abc&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- В реальности пароль будет получен &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- в соответствии с переданным user_id&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;store_avatar_URL_in&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithPassword&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithAvatarURL&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;store_avatar_URL_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;http://dshevchenko.biz/denis_avatar.png&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- В реальности URL будет получен &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- в соответствии с переданным user_id&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1234&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_login_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_info&lt;/span&gt; 
                                         &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_password_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; 
                                               &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;info_with_avatar_URL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_avatar_URL_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; 
                                                   &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;full_info_about_user&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_avatar_URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;full_info_about_user&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Красиво, не так ли? Давайте разберём это хозяйство по косточкам…&lt;/p&gt;

&lt;p&gt;Во-первых, новая для нас конструкция вида:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Очевидно, вы уже догадались, что это всего лишь добавление псевдонима для (уже известного) типа. Теперь вместо типа &lt;strong&gt;&lt;code&gt;String&lt;/code&gt;&lt;/strong&gt; можно использовать идентификатор &lt;code&gt;Login&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Далее мы определили простую функцию вида:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;user_info&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Тут всё просто: функция &lt;code&gt;user_info&lt;/code&gt; ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую результирующую строку.&lt;/p&gt;

&lt;p&gt;А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется лишь некий идентификатор пользователя, а соответствующие этому идентификатору логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, откуда получить логин, пароль и путь к аватару соответственно. Причём каждая из этих трёх функций является ФВП!&lt;/p&gt;

&lt;p&gt;Обратите внимание на следующие псевдонимы:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EmptyInfo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WithLogin&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithPassword&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AndWithAvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Каждый из них вводит упрощающее имя для функционального типа, образованного от типа функции &lt;code&gt;user_info&lt;/code&gt;. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Чтобы было понятнее, изобразим это с соответствующими сдвигами:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kt&quot;&gt;EmptyInfo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;WithLogin&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;          &lt;span class=&quot;kt&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;AndWithPassword&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;                &lt;span class=&quot;kt&quot;&gt;AvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;AndWithAvatarURL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;                            &lt;span class=&quot;kt&quot;&gt;UserId&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Каждый из этих псевдонимов задаёт сигнатуру для (очередной) промежуточной λ-функции, и нужно это, как вы уже догадались, для упомянутого выше частичного применения функции &lt;code&gt;user_info&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Рассмотрим первый вызов:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;        &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_login_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_info&lt;/span&gt; 
                                         &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы передаём функцию &lt;code&gt;user_info&lt;/code&gt; в качестве первого аргумента функции &lt;code&gt;store_login_in&lt;/code&gt;, внутри которой мы апплицируем переданную функцию &lt;code&gt;user_info&lt;/code&gt; к единственному аргументу, а именно к логину (потому что функция &lt;code&gt;store_login_in&lt;/code&gt; знает только о том, откуда и как получить логин). Соответственно, на выходе из функции &lt;code&gt;store_login_in&lt;/code&gt; мы получаем первую промежуточную λ-функцию, в которой мы как бы сохранили (store) значение логина (именно поэтому сигнатура этой λ-функции названа &lt;code&gt;WithLogin&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Далее следует вызов:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;        &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_password_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_login&lt;/span&gt; 
                                               &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы передаём нашу промежуточную λ-функцию (в которой мы как бы сохранили значение логина) в качестве первого аргумента функции &lt;code&gt;store_password_in&lt;/code&gt;. Эта функция, в свою очередь, апплицирует переданную ей λ-функцию к единственному аргументу, а именно к паролю (ибо функция &lt;code&gt;store_password_in&lt;/code&gt;, как вы уже поняли, умеет доставать только пароль). Таким образом, на выходе из функции &lt;code&gt;store_password_in&lt;/code&gt; мы имеем вторую промежуточную λ-функцию, в которой как бы сохранены уже два значения (полученный на предыдущем вызове логин и на этом вызове - пароль), именно поэтому сигнатура этой λ-функции носит имя &lt;code&gt;AndWithPassword&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;То же самое справедливо и для следующего вызова:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;        &lt;span class=&quot;n&quot;&gt;info_with_avatar_URL&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_avatar_URL_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_password&lt;/span&gt; 
                                                   &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;На выходе из функции &lt;code&gt;store_avatar_URL_in&lt;/code&gt; мы получаем третью λ-функцию, в которой как бы сохранены уже три значения: логин, пароль и путь к аватару.&lt;/p&gt;

&lt;p&gt;В итоге всё завершается апплицированием этой третьей λ-функции к последнему нужному аргументу, а именно к идентификатору пользователя:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;        &lt;span class=&quot;n&quot;&gt;full_info_about_user&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info_with_avatar_URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Именно здесь и происходит наконец “полноценный” вызов функции &lt;code&gt;user_info&lt;/code&gt;, в результате которого мы получаем и выводим на экран результирующую строку следующего вида:&lt;/p&gt;

&lt;bash&gt;
Full info about user @1234:
 login: denis
 password: 123456789abc
 avatar URL: http://dshevchenko.biz/denis_avatar.png
&lt;/bash&gt;

&lt;p&gt;Таким образом, функция &lt;code&gt;user_info&lt;/code&gt; была частично апплицирована три раза (каждый раз получая очередной аргумент), и лишь на четвёртый она получила все четыре необходимых ей аргумента. Мы можем сравнить это с конвейерной цепочкой, которую прошла данная функция: на каждом шаге она получала очередной аргумент.&lt;/p&gt;

&lt;p&gt;Итак, перед нами - живая демонстрация реальной пользы ФВП. Да, признаю, этот пример можно было бы упростить (в данном конкретном случае можно было обойтись без частичного применения), но цель была не в том, чтобы дать на 100% оптимальное решение, а в том чтобы продемонстрировать упомянутую выше теорию на практическом примере. И как вы смогли убедиться, эта теория лишь поначалу казалось нам страшноватой, в реальности же она достаточно проста.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2013/12/26/haskell-higher-order-functions.html&quot;&gt;Haskell: о функциях высшего порядка&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, декабрь 26, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Haskell: об инфиксных функциях]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2013/12/25/haskell-infix-functions.html"/>
  <id>http://blog.dshevchenko.biz/2013/12/25/haskell-infix-functions</id>
  <published>2013-12-25T00:00:00+04:00</published>
  <updated>2013-12-25T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Как мы уже знаем, вызов чистой функции выглядит так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Это соответствует идее апплицирования: мы применяем функцию &lt;code&gt;name&lt;/code&gt; к списку аргументов. Однако в математике существует и другая модель функции, а именно инфиксная модель. Если вы никогда не слышали это слово - не беспокойтесь, вы постоянно используете эту модель. Классический пример:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В данном случае у нас есть функция сложения, отражённая символом &lt;code&gt;+&lt;/code&gt;, которая принимает на вход два аргумента. Но если бы мы хотели записать этот вызов неинфиксным, классическим способом, то получилось бы вот что:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Всё как обычно: мы апплицируем функцию &lt;code&gt;(+)&lt;/code&gt; к двум аргументам. Однако предыдущая форма записи гораздо привычнее для нас, и при этом она значительно читабельнее.&lt;/p&gt;

&lt;p&gt;Так вот и наши собственные функции можно вызывать как классическим способом, так и инфиксным. Например:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;full_address&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;full_address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full_address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы определили функцию, принимающую строку, соответствующую IP-адресу, и целое число, соответствующее порту, и возвращающую строку с полным адресом (включающую хост и порт вместе). Как видите, мы вызвали её классическим способом. Но мы можем вызвать её и инфиксным способом. Для этого достаточно при вызове заключить имя функции в обратные одинарные кавычки (этот символ располагается обычно на клавише с тильдой). Выглядит это так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В инфиксной форме мы, как и со знаком сложения, заключаем имя функции &lt;em&gt;между&lt;/em&gt; аргументами.&lt;/p&gt;

&lt;p&gt;Давайте переименуем функцию для бОльшей литературности:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В этом случае инфиксная запись будет выглядеть значительно более привлекательно:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Довольно-таки симпатишно вышло. &lt;/p&gt;

&lt;p&gt;Конечно, инфиксную запись можно считать не более чем синтаксическим сахаром, но в ряде случаев такая запись может сделать код более удобным для чтения. Впрочем, чрезмерно увлекаться “инфиксностью” не рекомендуется (также как и, скажем, перегрузкой операторов в C++).&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2013/12/25/haskell-infix-functions.html&quot;&gt;Haskell: об инфиксных функциях&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, декабрь 25, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Haskell: устанавливаем пакет из Hackage]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2013/12/23/haskell-hackage.html"/>
  <id>http://blog.dshevchenko.biz/2013/12/23/haskell-hackage</id>
  <published>2013-12-23T00:00:00+04:00</published>
  <updated>2013-12-23T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;h3&gt;Готовимся&lt;/h3&gt;

&lt;p&gt;Все приведённые ниже команды выполняются в терминале из корневой папки нашего проекта.&lt;/p&gt;

&lt;p&gt;Для начала выполним команду:&lt;/p&gt;

&lt;bash&gt;
cabal update
&lt;/bash&gt;

&lt;p&gt;Эта команда обновляет список пакетов из вышеупомянутого репозитория, поэтому в ответ мы мы увидим нечто подобное:&lt;/p&gt;

&lt;bash&gt;
Downloading the latest package list from hackage.haskell.org
&lt;/bash&gt;

&lt;p&gt;Чуточку терпения - и список обновлён. Рекомендуется периодически выполнять эту команду, дабы поддерживать список доступных пакетов в актуальном состоянии.&lt;/p&gt;

&lt;h3&gt;Выбираем нужный пакет&lt;/h3&gt;

&lt;p&gt;Заходим на страницу списка пакетов и ищем. В частности, мне понадобилось установить пакет &lt;strong&gt;&lt;a href=&quot;http://hackage.haskell.org/package/filemanip&quot;&gt;filemanip&lt;/a&gt;&lt;/strong&gt;, предназначенный для работы с файловой системой. Кстати, поиск нужных вам пакетов можно производить в &lt;strong&gt;&lt;a href=&quot;http://www.haskell.org/hoogle/&quot;&gt;Hoogle&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Устанавливаем пакет следующей командой:&lt;/p&gt;

&lt;bash&gt;
cabal install filemanip
&lt;/bash&gt;

&lt;p&gt;В ответ последует список со всякими умными строками наподобие этого:&lt;/p&gt;

&lt;bash&gt;
...
Downloading filemanip-0.3.6.2...
Configuring filemanip-0.3.6.2...
Building filemanip-0.3.6.2...
...
Installing library in
/Users/dshevchenko/Library/Haskell/ghc-7.6.3/lib/filemanip-0.3.6.2/lib
Registering filemanip-0.3.6.2...
Installed filemanip-0.3.6.2
Updating documentation index /Users/dshevchenko/Library/Haskell/doc/index.html
&lt;/bash&gt;

&lt;p&gt;Итак, пакет установлен.&lt;/p&gt;

&lt;h3&gt;Указываем пакет в .cabal-файле&lt;/h3&gt;

&lt;p&gt;Открываем конфигурационный &lt;code&gt;.cabal&lt;/code&gt;-файл (помните про такой, не так ли?), находящийся в корне нашего проекта, и дописываем наш только что установленный пакет:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;executable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Haskell&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hs&lt;/span&gt;            
    &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modules&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;Haq&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirs&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; 
                     &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depends&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filemanip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Как видите, мы просто дописали в параметр &lt;code&gt;build-depends&lt;/code&gt; название нового пакета. Обратите внимание, что имена пакетов в этом параметре указываются через запятую, это важно.&lt;/p&gt;

&lt;p&gt;Если вы пропустите этот шаг, то воспользоваться каким-либо из модулей данного пакета вы, разумеется, не сможете. Напоминаю, что пакет представлен набором модулей, которые можно импортировать в ваш код (а импорт модуля, напоминаю, подобен включению файла с помощью &lt;code&gt;#include&lt;/code&gt;-директивы).&lt;/p&gt;

&lt;p&gt;Впрочем, даже если вы всё-таки забудете указать установленный пакет &lt;em&gt;и при этом&lt;/em&gt; попытаетесь импортировать какие-либо из его модулей в ваш проект, компилятор вежливо поправит вас:&lt;/p&gt;

&lt;bash&gt;
src/main.hs:3:8:
    Could not find module `System.FilePath.Find&#39;
    It is a member of the hidden package `filemanip-0.3.6.2&#39;.
    Perhaps you need to add `filemanip&#39; to the build-depends in your .cabal file.
    Use -v to see a list of the files searched for.
&lt;/bash&gt;

&lt;h3&gt;Подключаем нужные модули&lt;/h3&gt;

&lt;p&gt;А теперь открываем наш файл (например, &lt;code&gt;main.hs&lt;/code&gt;) и дописываем в его верхней части следующую строку:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.FilePath.Find&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Этой инструкцией мы импортировали конкретный модуль из установленного пакета. Теперь мы сможем использовать содержимое этого модуля в нашем проекте.&lt;/p&gt;

&lt;p&gt;Напоследок выполним команды:&lt;/p&gt;

&lt;bash&gt;
cabal configure
cabal build
&lt;/bash&gt;

&lt;p&gt;Готово!&lt;/p&gt;

&lt;p&gt;Лично мне очень понравилась такая философия работы с пакетами. Во-первых, утилита cabal предоставляет единый централизованный способ установки пакетов, во-вторых, сама установка занимает три простейших шага (установить, прописать в &lt;code&gt;.cabal&lt;/code&gt;-файле, импортировать нужные модули), а в-третьих, я могу установить только те пакеты, которые мне реально нужны.&lt;/p&gt;

&lt;p&gt;На сегодня достаточно, но мы обязательно продолжим изучение &lt;code&gt;cabal&lt;/code&gt;, а уж к пакетам из Hackage мы будем возвращаться не раз и не два.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2013/12/23/haskell-hackage.html&quot;&gt;Haskell: устанавливаем пакет из Hackage&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, декабрь 23, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Haskell: о функциях]]></title>
  <link rel="alternate" type="text/html" href="http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html"/>
  <id>http://blog.dshevchenko.biz/2013/12/23/haskell-functions</id>
  <published>2013-12-23T00:00:00+04:00</published>
  <updated>2013-12-23T00:00:00+04:00</updated>
  <author>
    <name>Денис Шевченко</name>
    <uri>http://blog.dshevchenko.biz</uri>
    <email>me@dshevchenko.biz</email>
  </author>
  <content type="html">&lt;p&gt;Если вы помните &lt;strong&gt;&lt;a href=&quot;http://dshevchenko.biz/ru/content/haskell-%D0%BE-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85&quot;&gt;заметку о лямбда-функциях&lt;/a&gt;&lt;/strong&gt;, математическое определение функции очень простое:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Функция - это описание зависимости чего-то от чего-то.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Так вот чистые функции в языке Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, &lt;em&gt;как&lt;/em&gt; входное выражение (или совокупность таковых) определяет выходное выражение. Именно поэтому они не имеют побочных эффектов, и если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз получим один и тот же ответ.&lt;/p&gt;

&lt;p&gt;А теперь за дело.&lt;/p&gt;

&lt;h3&gt;Объявляем&lt;/h3&gt;

&lt;p&gt;Начинается всё с объявления функции:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Перед нами - объявление выражения. До символа &lt;code&gt;::&lt;/code&gt; указывается имя выражения, а после - тип выражения. &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
   &lt;span class=&quot;err&quot;&gt;имя&lt;/span&gt;           &lt;span class=&quot;err&quot;&gt;тип&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Итак, перед нами выражение с именем &lt;code&gt;simple_sum&lt;/code&gt;, имеющее тип функции. Пусть вас не смущают эти слова: в Haskell функция - это тоже тип. Но откуда же мы знаем, что тип этого выражения представляет собой именно функцию? Давайте рассмотрим описание типа подробнее:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами функция. Слева от неё указан тип единственного аргумента функции (в данном случае это стандартный тип &lt;strong&gt;&lt;code&gt;Int&lt;/code&gt;&lt;/strong&gt;), а справа от неё - тип выходного выражения (тот же &lt;strong&gt;&lt;code&gt;Int&lt;/code&gt;&lt;/strong&gt;). Саму же стрелочку можно воспринимать как ментальное указание на поток информации через функцию - от входа к выходу, слева направо.&lt;/p&gt;

&lt;p&gt;В силу того, что чистая функция в Haskell является математической, невозможно написать аналоги вот таких C-шных функций:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Чистая функция в Haskell обязана иметь входной аргумент (хотя бы один) и выходное значение. Почему? Потому что это отражает суть математической функции: что-то &lt;em&gt;обязательно&lt;/em&gt; подаём на вход и что-то &lt;em&gt;обязательно&lt;/em&gt; получаем на выходе.&lt;/p&gt;

&lt;p&gt;Кстати, о количестве аргументнов. Разумеется, чистая функция может принимать несколько аргументов. В этом случае её тип будет выглядеть так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Я понимаю, выглядит чуток странно, но читать это очень просто: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;типы&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;аргументов&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;тип&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;того&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;что&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;будет&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;на&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;выходе&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Итак, с объявлением разобрались. Идём дальше.&lt;/p&gt;

&lt;h3&gt;Определяем&lt;/h3&gt;

&lt;p&gt;Теперь функцию нужно определить. Кстати, определить нужно &lt;em&gt;обязательно&lt;/em&gt;. Известно, что в том же C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда нигде не вызывается). В Haskell более строгий подход: если объявил - будь добр и определить, в противном случае компилятор выскажет своё недовольство.&lt;/p&gt;

&lt;p&gt;Итак, сразу после объявления пишем тело функции:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Рассмотрим его подробнее:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Здесь ментальным разделителем является знак равенства. Напоминаю, что в Haskell нет оператора присваивания, поэтому знак равенства здесь - это именно &lt;em&gt;знак равенства&lt;/em&gt;, как в математике. Скелет данного выражения можно представить так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body_expression&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Здесь:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;name&lt;/code&gt; - имя функции.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;arguments&lt;/code&gt; - список имён аргументов (именно имён, а не их типов).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;body_expression&lt;/code&gt; - тело функции.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В данном случае у нас имеется один-единственный аргумент по имени &lt;code&gt;value&lt;/code&gt;, а также имеется чрезвычайно простое тело, в котором мы просто-напросто складываем аргумент с самим собой.&lt;/p&gt;

&lt;h3&gt;Вызываем&lt;/h3&gt;

&lt;p&gt;Теперь нашу функцию можно вызывать с аргументом 4 (или, как привычно говорить в мире ФП, апплицировать функцию к аргументу 4):&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simple_sum&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В ответ получаем ожидаемое значение:&lt;/p&gt;

&lt;bash&gt;
8
&lt;/bash&gt;

&lt;h3&gt;А теперь подробнее...&lt;/h3&gt;

&lt;p&gt;Естественно, всё вышесказанное - это лишь самые азы. Теперь же необходимо уточнить некоторые детали.&lt;/p&gt;

&lt;h4&gt;Выход из функции&lt;/h4&gt;

&lt;p&gt;В C++, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле написать инструкцию &lt;strong&gt;&lt;code&gt;return&lt;/code&gt;&lt;/strong&gt;. Это - точка выхода из тела функции. Кроме того, мы знаем, что точек выхода из тела функции может быть сколько угодно. В Haskell же всё обстоит иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции &lt;strong&gt;&lt;code&gt;return&lt;/code&gt;&lt;/strong&gt; в Haskell нету.&lt;/p&gt;

&lt;p&gt;Да, я понимаю, это удивляет. Мол, а как же нам быть, если мы хотим указать точку выхода явно? Но если мы вспомним математическую природу чистой функции, то поймём, что иначе быть не может. Ведь чистая функция представляет собой описание зависимости выходного выражения от совокупности входных выражений, поэтому её тело представляет собой совокупность выражений, которые вычисляются (в некотором порядке) и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться точкой выхода из функции.&lt;/p&gt;

&lt;p&gt;Чтобы стало понятнее, приведу пример:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Эта функция принимает единственный аргумент типа &lt;strong&gt;&lt;code&gt;String&lt;/code&gt;&lt;/strong&gt;, соответствующий некоему IP-адресу. В теле функции происходит проверка аргумента на равенство адресу “127.0.0.1”, в результате мы оказываемся в одной из двух логических ветвей. Если бы это была функция на C++, это выглядело бы примерно так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Обратите внимание, что мы явно указали две точки выхода из функции. Но в Haskell это не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, оно и будет возвращено.&lt;/p&gt;

&lt;p&gt;А чтобы стало совсем понятно, перепишем тело этой функции для того, чтобы избавиться от выражения &lt;strong&gt;&lt;code&gt;if then else&lt;/code&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Мы вводим вместо одного тела два, для каждого из которых мы определяем свою зависимость. Мы как бы говорим: “Если входной аргумент будет равен “127.0.0.1”, то пусть возвращаемым функцией значением будет строка “localhost”, если же аргумент будет какой-либо другой, то пусть возвращаемым функцией значением будет сам этот аргумент.” Следовательно, когда компилятор увидит вызов этой функции в коде, он просто &lt;em&gt;подставит&lt;/em&gt; на место этого вызова соответствующее выражение: либо строку “localhost”, либо фактически переданный аргумент.&lt;/p&gt;

&lt;p&gt;Теперь всё встало на свои места: явно определять точку выхода из чистой функции в Haskell не нужно потому, что конечное выражение в теле этой функции просто заменит собой вызов функции. То есть если написано так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;то это то же самое, что было бы написано так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;потому что компилятор, вычислив внутренности функции, просто заменит место вызова конечным (итоговым) выражением.&lt;/p&gt;

&lt;h4&gt;Локальные выражения&lt;/h4&gt;

&lt;p&gt;Очень полезно бывает ввести некое локальное значение в теле функции, например, для избавления от дубляжа кода или от магических чисел. Например, у нас есть такая функция:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4959&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Итак, мы готовим длину некой линии путём умножения её первоначальной длины на поправочный коэффициент. Но перед нами - магическое число, а это очень плохо. Добавлять комментарий - это не лучшее решение. Поэтому добавим локальное поясняющее выражение:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4959&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Красиво, не так ли? Ключевое слово &lt;strong&gt;&lt;code&gt;where&lt;/code&gt;&lt;/strong&gt; вводит локальное выражение, которое можно использовать в теле функции. Разумеется, локальных выражений может быть несколько:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4959&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0012&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Есть ещё один способ ввести локальное вспомогательное выражение, с помощью ключевого слова &lt;strong&gt;&lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;. На примере нашей последней функции это выглядит так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.4959&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0012&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Общая модель такая: &lt;strong&gt;&lt;code&gt;let&lt;/code&gt;&lt;/strong&gt; &lt;code&gt;bindings&lt;/code&gt; &lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; &lt;code&gt;expression&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Но у вас, очевидно, возник вопрос, в чём же разница между &lt;strong&gt;&lt;code&gt;where&lt;/code&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Во-первых, выражение &lt;strong&gt;&lt;code&gt;where&lt;/code&gt;&lt;/strong&gt; может быть только одно и только в конце тела функции, в то время как выражение &lt;strong&gt;&lt;code&gt;let&lt;/code&gt;&lt;/strong&gt; может присутствовать многократно и в любой части тела функции.&lt;/p&gt;

&lt;p&gt;Во-вторых, выражение, введённое ключевым словом &lt;strong&gt;&lt;code&gt;where&lt;/code&gt;&lt;/strong&gt;, всегда видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом &lt;strong&gt;&lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;, может быть “супер-локальным”. Например:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.4959&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0012&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;correction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.9&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Понимаю, пример несколько надуманный, но всё-таки… Здесь мы ввели выражение с именем &lt;code&gt;s&lt;/code&gt;, которое действует только внутри круглых скобок. Именно поэтому пример этот не скомпилируется, ведь второе выражение &lt;code&gt;s&lt;/code&gt; находится уже не в скобках, и поэтому компилятор вполне справедливо возмутится:&lt;/p&gt;

&lt;bash&gt;
[2 of 2] Compiling Main             ( src/main.hs, dist/build/Haskell/Haskell-tmp/Main.o )

src/main.hs:43:61: Not in scope: `s&#39;
&lt;/bash&gt;

&lt;h4&gt;Про объявление&lt;/h4&gt;

&lt;p&gt;Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Отвечаю: можно, но не рекомендуется.&lt;/p&gt;

&lt;p&gt;Общепринятой практикой является объявлять функцию и тут же определять её. И несмотря на то, что мы &lt;em&gt;можем&lt;/em&gt; написать так:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;prepare_length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.4959&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficient&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;делать так не рекомендуется, поскольку определение функции становится как бы беднее, ведь сигнатура типов аргументов и возвращаемого выражения помогает лучше понять функцию.&lt;/p&gt;

&lt;p&gt;К тому же в случае отсутствия объявления тип аргумента &lt;code&gt;line&lt;/code&gt; становится неопределённым, и поэтому строгость проверки этого самого типа (на стадии компиляции) снизится. Если вы делаете это &lt;em&gt;сознательно&lt;/em&gt; - три раза подумайте. Во всех же остальных случаях -  объявляйте.&lt;/p&gt;

&lt;h4&gt;Вот и всё?&lt;/h4&gt;

&lt;p&gt;Конечно, это далеко не всё, что можно сказать о чистых функциях, но этот базис достаточен для того, чтобы понять суть чистых функций и то, как их можно использовать в своём коде. Продолжение следует…&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.dshevchenko.biz/2013/12/23/haskell-functions.html&quot;&gt;Haskell: о функциях&lt;/a&gt; опубликовано Денисом Шевченко на &lt;a href=&quot;http://blog.dshevchenko.biz&quot;&gt;Мысли вслух&lt;/a&gt;, декабрь 23, 2013.&lt;/p&gt;</content>
</entry>

</feed>
