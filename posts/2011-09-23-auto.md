---
title: auto и обобщённая инициализация: проблема?
tags: C++
---

В общем, там описана "типа проблема".

Итак:
```cpp
int main() {
    auto i{10};
    std::cout << i << std::endl;
}
```

Такой код не скомпилируется. Ошибка: no match for ‘operator<<’ in ‘std::cout << i’.

Э-э... Как это "нет оператора"? С каких это пор целочисленное значение в поток вывода запихнуть нельзя?!

Проблемы тут на самом деле никакой нет, программа сделала именно то, что мы ей сказали сделать.

Когда мы пишем:
```cpp
    auto i{10};
```
на стадии компиляции тип i определяется по типу правого значения. Так ведь справа-то у нас стоит не целочисленное значение, а {10}. Это - так называемый "список инициализации", один из стандартных (в C++11) типов.

Таким образом, i - это список инициализации, содержащий одно целочисленное значение 10. И вот этот список инициализации мы пытаемся вывести в std::cout. Ага, щаз!

Вывод прост: обобщённая инициализация с фигурными скобками чрезвычайно полезна, но она должна использоваться разумно. Её не нужно пихать везде и всюду. Понятно, что автор вышеприведённого примера имел в виду целочисленное значение. Это можно было написать так:
```cpp
int main() {
    auto i(10);
    std::cout << i << std::endl;
}
```
или так:
```cpp
int main() {
    auto i = 10;
    std::cout << i << std::endl;
}
```
и никаких проблем.
