---
title: Исключение в конструкторе: о, сколько нам открытий чудных...
tags: C++
---

Известно, что исключения (в идеале никогда) не должны покидать тело конструктора, в противном случае соответствующий деструктор так и не будет вызван. 

А что если будет вот так:

```cpp
struct A {
    A() {
        std::cerr << "A" << std::endl; 
    }
    
    ~A() { 
        std::cerr << "~A" << std::endl; 
    }
};

struct B : A {
    B() { 
        std::cerr << "B" << std::endl;
        throw std::logic_error( "" );
    }
    
    ~B() { 
        std::cerr << "~B" << std::endl; 
    }
};
```

Итак, имеем базовый класс A и наследник B. В конструкторе наследника возникает исключение и улетает в пресветлые дали. Деструктор наследника вызван не будет. А теперь вопрос: будет ли вызван деструктор базового класса?

Взглянем на вывод:

<bash>
A
B
terminate called after throwing an instance of 'std::logic_error'
  what():

Command terminated
</bash>

Как видим, ни деструктор базового класса, ни деструктор наследника вызван не был.

Казалось бы, это удивляет. Если конструктор базового класса был полностью завершён, то можно предположить, что конструирование его прошло успешно, а следовательно, и его деструктор должен был вызваться. Так? Нет, не так. Уберём исключение и проверим вывод:

<bash>
A
B
~B
~A
</bash>

Всё встаёт на свои места. Разрушение происходит в порядке, обратном конструированию, поэтому деструктор базового класса A будет вызван **после** деструктора наследника B. Следовательно, если последний вызван не будет (из-за исключения), то и первый - тоже.
