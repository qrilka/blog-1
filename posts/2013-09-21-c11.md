---
title: C++11: пользовательские литералы
tags: C++11
---

Наконец-то дошли руки и до этого зверя...

Одним из нововведений в стандарте C++11 являются "User-defined literals", или пользовательские литералы. Ну, с пользовательскими типами знакомы все, а вот что за литералы такие? На самом деле, всё предельно просто: речь идёт о хитром варианте перегрузки операторов, только и всего. Но получилась довольно симпатичная штука. 

Кстати, пользоваться этим механизмом могут обладатели GCC 4.7 и более поздних версий. Любопытный факт: несмотря на то, что GCC 4.7 вышел в марте 2012, идея введения пользовательских литералов ощутимо старше: соответствующее техническое предложение для Комитета по стандартизации C++ было сформулировано уже в 2008 году. Видимо, долго думали... :)

Итак, приступим. Представьте себе такой код:

```cpp
int main() {
    int const font_size( px( 12 ) );
    std::cerr << font_size << std::endl;
}
``` 

Здесь мы используем функцию **px** для избавления от магического числа 12.0, ибо размер шрифта может быть не только в пикселях, но и, например, в пунктах (pt) или в миллиметрах. А теперь представьте себе этот же код в таком виде:

```cpp
int main() {
    int const font_size( 12_px );
    std::cerr << font_size << std::endl;
}
``` 

Необычно, правда? Необычно и значительно более читабельно. Это один из примеров пользовательского литерала. Определяется он следующим образом:

```cpp
typedef unsigned long long ullong;
constexpr ullong operator"" _px ( ullong value_in_px ) {
    return value_in_px;
}
```

Ключевое слово **operator** сразу сигнализирует нам о <del>синтаксическом сахаре</del> перегрузке операторов. Слово **_px** определяется подобно любой операторной функции, но используется в коде как часть явно прописанного значения, оттого и название "литерал":

```cpp
12_px;
```

Здесь значение 12 передаётся литералу в качестве единственного аргумента типа unsigned long long. Вы спросите, почему именно **unsigned long long**? Дело в том, что набор типов для определяемого пользователем литерала строго определён, а именно:

<ol>
  <li><code>operator"" name ( unsigned long long n ) ...</code></li>
  <li><code>operator"" name ( long double d ) ...</code></li>
  <li><code>operator"" name ( char c ) ...</code></li>
  <li><code>operator"" name ( const char* str, size_t sz ) ...</code></li>
  <li><code>operator"" name ( const char* cstr ) ...</code></li>
</ol>

При попытке определить аргумент с другим типом (например, с **int**) компилятор грозно сообщит:

<bash>
'constexpr int operator"" _px(int)' has invalid argument list
</bash>

<h3>Практическое применение</h3>

Ну, самое первое и самое простое применение уже было продемонстрировано выше - пользовательский литерал может избавить нас от магических чисел:

```cpp
90.0_degrees;
1200_km;
0.01_mg;
```

Единицы измерения указаны явно - получаем значительно более читабельный код.

Кроме того, **<a href="http://dshevchenko.biz/ru/content/%D0%BF%D0%BE%D1%8F%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B5%D0%B7-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B5%D0%B2-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80">в одной заметке я писал</a>** о пояснении кода без комментариев. Литералы придут на помощь и тут:

```cpp
placer->set_margins(   2_px_at_left
                     , 2_px_at_top
                     , 2_px_at_right
                     , 2_px_at_bottom );

// Чуть ниже, в этой же области видимости...
placer->set_margins(   3_px_at_left
                     , 5_px_at_top
                     , 4_px_at_right
                     , 4_px_at_bottom );
```

Согласитесь, красиво и предельно понятно.

Не менее полезно использование литералов для аргументов других типов. Например, если нам нужно перевести дату (заданную строкой) в ISO-вид, то можно определить литерал так:

```cpp
std::string operator"" _as_ISO( const char* date, size_t length ) {
    using namespace boost::posix_time;
    ptime t( time_from_string( std::string(   date
                                            , length ) ) );
    return to_iso_string( t );
}
```

Теперь пишем так:

```cpp
int main() {
    std::cerr << "ISO date: " 
              << "2013-Jan-20 23:59:59"_as_ISO 
              << std::endl;
}
```

Получаем:

<bash>
ISO date: 20130120T235959
</bash>

Честно признаюсь, в некоторых моих прошлых проектах я был бы очень рад использовать подобное преобразование.

<h3>Будьте аккуратны с форматированием</h3>

Обращаю ваше внимание на то, что с форматированием при использовании пользовательских литералов нужно быть чуток внимательным.

Во-первых, при определении:

```cpp
std::string operator""_as_ISO( const char* date, size_t length ) ...
```

Видите? Мы убрали пробел перед именем литерала. Однако компилятор не согласится с нашими планами и немедленно ругнётся:

<bash>
missing space between '""' and suffix identifier
</bash>

Во-вторых, при использовании:

```cpp
"2013-Jan-20 23:59:59" _as_ISO;
```

Здесь, напротив, мы добавили пробел перед именем литерала. Но компилятор и тут заупрямится:

<bash>
expected ';' before '_as_ISO'
</bash>

Таким образом, там - строго с пробелом, а тут - исключительно без пробела.

<h3>Конвенция имени</h3>

Вы, очевидно, обратили внимание на то, что имя литерала везде начинается со знака подчёркивания? На самом деле я могу и не использовать его:

```cpp
std::string operator"" as_ISO( const char* date, size_t length ) ...
```

И код скомпилируется, однако с предупреждением:

<bash>
literal operator suffixes not preceded by '_' are reserved for future standardization
</bash>

Оказывается, литералы, не начинающиеся с подчёркивания, считаются зарезервированными. А мы знаем, что использовать что-либо зарезервированное крайне не рекомендуется. В общем, на свой страх и риск...

К тому же, в силу того, что имя литерала должно идти впритык со значением, знак подчёркивания добавляет "визуальный пробел", не давая значению и имени литерала слиться воедино. Сравните:

```cpp
"2013-Jan-20 23:59:59"as_ISO;
```

и:

```cpp
"2013-Jan-20 23:59:59"_as_ISO;
```

Ну, это конечно на любителя, но лично я предпочту второй вариант.

<h3>Ну и что же мы имеем в итоге?</h3>

В итоге мы имеем вкусный синтаксический сахар. Лично я считаю этот механизм весьма полезным, хотя конечно далеко не самым значимым из нововведений C++11. Сама идея перегрузки (любого) оператора подразумевает лишь украшение кода, не более чем. Да, красиво, да, короче, но увлекаться этим не надо.

Например, я видел такой пример:

```cpp
long double operator"" _deg( long double d )
{ 
    // returns radians
    return d * M_PI / 180;
}
```

То есть если мы напишем так:

```cpp
auto angle = 90.0_deg;
```

то **angle** содержит значение в радианах. Однако из кода вызова литерала сей факт ну абсолютно не следует, и пока мы не взглянем на реализацию, нам и на ум не придёт, что здесь происходит конвертация из градусов в радианы. То есть здесь конвертация предстаёт перед нами как скрытый побочный эффект, а это не есть хорошо. Поэтому будьте внимательны: если уж пишете так чтобы было красиво и понятно, делайте это так, чтобы понятно было не только вам...
