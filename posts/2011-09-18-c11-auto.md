---
title: C++11: циклы с auto
tags: C++11
---

Циклы нужны всегда. И auto может облегчить нашу жизнь в их написании.

Итак, классический итеративный цикл:
``` cpp
typedef std::vector< int > V;
typedef V::const_iterator  It;

V v = { 1, 2, 3 };
for ( It it = v.begin(); it != v.end(); ++it ) {
    std::cout << *it << std::endl;
}
```

Применяя auto, можно упростить данный код:
```cpp
typedef std::vector< int > V;

V v = { 1, 2, 3 };
for ( auto it = v.begin(); it != v.end(); ++it ) {
    std::cout << *it << std::endl;
}
```
Однако создатели нового стандарта пошли ещё дальше. Ведь в данном коде мы продолжаем иметь дело с итераторами, пусть даже их тип и определяется автоматически.

Если предполагается поэлементное итерирование всего контейнера (а это 99% случаев), то синтаксис упрощается до (несколько необычного) вида:
```cpp
typedef std::vector< int > V;

V v = { 1, 2, 3 };
for ( auto value : v ) {
    std::cout << value << std::endl;
}
```
Согласитесь, красиво! Итераторы тут, как видите, не фигурируют вовсе, а вместо value подставляется уже само значение элемента контейнера (в данном случае это число типа int).

Не хотим копировать при итерировании? Пишем там:
```cpp
typedef std::vector< some_my_type > V;

V v; // Наполняем каким-то образом, не важно...
for ( const auto& value : v ) {
    // Что-то делаем с value, имеющим тип some_my_type.
}
```
Но, к сожалению, мой компилятор (g++ 4.4.5) даже с флагом нового стандарта пока ещё не поддерживает данную конструкцию. Решение нашлось быстро:
```cpp
typedef std::vector< int > V;

V v = { 1, 2, 3 };
BOOST_FOREACH ( auto value, v ) {
    std::cout << value << std::endl;
}
```
По-моему, не менее красиво получилось. Да, мы имеем дело с (формально) сторонним макросом. Да, он уступает в скорости итерирования for-циклу. Но для подавляющего большинства случаев это решение всецело подходит.

Преимущества auto в циклах очевидны:
<ol>
 <li>Упрощение кода (согласитесь, тут труднее совершить ошибку)</li>
 <li>Обобщение кода (изменился тип контейнера - код циклов остаётся прежним)</li>
</ol>

*P.S. И всё-таки не забывайте, что циклов (пусть даже и столь продвинутых) лучше избегать вовсе, заменяя их алгоритмами.* :-)
