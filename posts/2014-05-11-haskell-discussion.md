---
layout: post
title: В защиту Haskell: по следам одного Хабра-спора...
category: articles
tags: [Haskell]
comments: true
share: true
---

На бескрайних просторах Хабра встретилась мне одна [любопытнейшая тема](http://habrahabr.ru/post/133277/). Она довольно стара (ноябрь 2011 года), но это не делает её менее интересной. И интересна она не только тем, что предельно понятным языком объясняет суть теории категорий (да-да, того самого "страшного" математического раздела, из которого вышли понятия монады, моноида и иже с ними), но и тем, что в комментариях к этой теме завязалась примечательная дискуссия. На самом деле, дискуссия там весьма обширна, но меня зацепили комментарии одного пользователя, некоего Бахтерева Михаила Олеговича (зарегистрированного под ником `mikhanoid`).

Вот с чего всё началось:

> Эх. Вот было бы ещё в Haskell так же просто байтик по адресу 0xb8000 записать, цены бы ему не было. А так. Ну да, математика, на да, формально, ну да, можно мозг поупражнять. А дальше? А ведь не особо опытные менджеры уже начинают пытаться внедрять Haskell в production. Ужас. 

Затравка цепляет. Ему совершенно справедливо отвечают, мол, не все задачи сводятся к «записать байтик». На что он говорит:

> В разработке software — все. Как бы всё равно никому ещё не удалось разработать не-фон-Неймановский универсальный процессор. А там запись байтиков направо и налево :) И вот нам говорят: машина работает одним способом, но нет, мы не будем придумывать язык, который позволит естественное для машины поведение программировать наиболее естественным образом. Мы, наоборот, абстрагируемся, а потом будем ковыряться левой пяткой в правом ухе для решения простейших задач. Не понимаю я, к чему это?

Выходит, абстрагирование от архитектуры процессора вынуждает нас ковыряться левой пяткой в правом ухе для решения простейших задач... Довод из прошлого тысячелетия, но ладно уж, продолжим:

> Дело не собственно в памяти. Чтобы организовать обмен данными с внешним миром, нам нужно иметь канал связи с этим миром. А канал связи — это система, у которой нужно явно менять состояния. Если мы рассматриваем сам Haskell (ну, или любой чистый функциональный язык), то там нет такой концепции. Нельзя изменить состояние канала, можно только лишь создать новый канал. Но как внешний мир может узнать об изменении канала связи?

> Вот в чём проблема. В Haskell, конечно, есть и указатели, и ссылки, и IO, но их невозможно запрограммировать на самом Haskell, поэтому они создаются искусственно, через специальные монады связанные со внешними библиотеками на Си. И эти монады отличаются от тех, которые можно создать на самом Haskell.

И ещё:

> Так это и есть философская проблема. Скажем, для Си или даже, допустим, Lua, вывод на консоль может быть написан на самих Си или Lua. А чистый функциональный язык уже не допускает этого.

> И тут нельзя сказать, что это просто консоль неправильная, не функциональная, потому что не может быть функциональной консоли.

И вывод:

> Поэтому нельзя на функциональном языке выразить работу с оборудованием и внешним миром. Нужны всякие костыли разной степени костыльности. 

Вот такие доводы. К слову, этот Михаил Олегович - человек очень опытный, достаточно взглянуть на его темы на Хабре. Разумеется, вступать с таким человеком в дискуссию на его уровне я бы не стал, ибо занимаюсь задачами куда как менее сложными, чем он. Поэтому выскажу своё мнение как практик. 

Рассмотрим вот такую строку:

{% highlight haskell %}
main = readFile "/Users/dshevchenko/text" >>= putStr
{% endhighlight %}

Содержимое файла `/Users/dshevchenko/text` выводится на консоль. Вы представляете себе, сколько различных программных действий совершается от момента запуска такого кода до момента отображения текста файла в терминале? Их очень много, начиная от вызовов библиотечных функций и заканчивая работой ряда драйверов. И если бы мы очень захотели, то могли бы перечислить все эти действия. Только нужно ли нам это? Нет, нам нужно вывести содержимоей файла на консоль. И такой код прекрасно справляется с этой задачей. 

К чему это я... Михаил Олегович совершенно справедливо отмечает, что на Haskell *как таковом* нельзя напрямую взаимодействовать с адресами байтов, и поэтому, разумееется, вывод на консоль не может быть написан на чисто функциональном языке. Однако, насколько я понял тон Михаила Олеговича, он ставит сей факт в укор чисто функциональному подходу как таковому. Мол, раз на нём нельзя явно изменять состояние областей памяти, значит этот язык пригоден исключительно для теоретически-академических целей, а места в real world ему нету...

И вот сижу я и думаю - а почему, собственно, это такая проблема? Понятно, что где-то под капотом Haskell есть системные функции, написанные на старом добром C, и именно эти функции выполняют всю низкоуровневую работу. Но мне-то зачем об этом знать? Я, как программист-практик, знать этого не хочу, да и не обязан. Разумеется, в процессе выполненения кода, выводящего текст на консоль, происходит многократное изменение различных программных состояний, но мне до этого нет никакого дела. Если всё это под капотом, пусть там и остаётся, а я лучше буду думать о моих задачах, а не о том, как там байтики записываются.

И я считаю, это очень хорошо и правильно, что вся низкоуровневая работа делегируется коду, написанному на языке C. Вы что думаете, в том же C++ память выделяется оператором `new`? Нет, она выделяется старой доброй `malloc`, а `new` есть не более чем удобный синтаксический сахар. Значит ли это, что мы не должны пользоваться оператором `new`? Едва ли...

Так что в наших процессорах байтики пусть записываются направо и налево, а мы, живущие в 2014 году, позволим себе думать уже не о байтиках, а о других вещах.



