---
layout: post
title: Clang вместо GCC на OS X: первый опыт
category: articles
tags: [GCC, Clang]
comments: true
share: true
---

В общем, не GCC единым жив программист...

Я слышал о Clang уже давно. "Замена для GCC" - так позиционируется Clang в википедии. Признаться, я не очень понимал, зачем нужно заменять GCC, если он стал уже стандартом де-факто во всех Unix-подобных системах. Однако, как выяснилось, я отстал от жизни, ведь уже год назад разработчики FreeBSD заменили GCC на Clang. И это при том, что FreeBSD всегда считалась весьма консервативной ОС.

В общем, я решил рискнуть - и попробовать это хозяйство. Дело в том, что шальная мысль - а именно перейти с Qt 4.8.1 на Qt 5.0.1 для Style Revisor - вылилась в твёрдое решение, и я подумал: а что если скомпилировать новую версию Style Revisor с помощью Clang? (Вообще-то была мысль попробовать свеженький GCC 4.8.0, но как вспомню, сколько часов его нужно компилить... В общем, поленился я...)

Сказано - сделано. А что сделано - о том и раскажу.

Итак:
<ol>
  <li>Идём на страницу скачивания: http://llvm.org/releases/download.html#3.2.</li>
  <li>Находим ссылку: **Clang Binaries for MacOS X/x86_64**.</li>
  <li>Скачиваем и распаковываем архив.</li>
  <li>Переименовываем с длинного **clang+llvm-3.2-x86_64-apple-darwin11** во что-нибудь покороче, я решил назвать просто **clang**.</li>
  <li>Копируем это хозяйство в какое-нибудь удобное место. У меня это **/Users/dshevchenko/Tools**.</li>
</ol>
Возможно, вы будете удивлены, но это всё. :)

Создаём в домашней папке пробный main.cpp, и вводим следующую команду:
```cpp
~/Tools/clang/bin/clang++ -std=c++11 -stdlib=libc++ -I/usr/local/include/libcxx main.cpp -o hello
```

А вот теперь пару слов об этой самой команде...

Ну, флаг **-std=c++11** знаком нам уже очень хорошо (а если кто не знает - этот флаг говорит компилятору о необходимости вспомнить стандарт C++11), но что такое **-stdlib=libc++** и зачем мы указываем Clang-у какие-то дополнительные заголовочники через флаг **-I**?

Дело в том, что Clang в качестве стандартной библиотеки C++ может использовать два варианта: либо стандартную библиотеку, идущую вместе с GCC (а именно libstdc++), либо свою собственную. Я решил не мудрствовать лукаво, и использовать первый вариант. В конце концов, стоило ли брать компилятор А, чтобы использовать вместе с ним библитеку, идущую с компилятором Б?

Итак, стандартная библиотека C++, о которой пойдёт речь, носит имя **libc++**. Вот её страница: http://libcxx.llvm.org. В описании читаем:
<pre>
libc++ is a new implementation of the C++ standard library, targeting C++11.
</pre>
Ну что ж, звучит обнадёживающе. Более того, собирать эту библиотеку мне не пришлось, ибо она уже лежала в **/usr/lib**.

Однако STL-заголовочники я решил обновить, дабы свежее было. Тут всё просто:
<ol>
  <li>Выполняем команду **svn co http://llvm.org/svn/llvm-project/libcxx/trunk/include libcxx**.</li>
  <li>Копируем папку в какое-нибудь понятное место, у меня это **/usr/local/include**.</li>
</ol>
Собственно, всё. Именно поэтому мы и должны указать Clang-у факт того, что хотим использовать **libc++** в качестве стандартной библиотеки, а также путь к новым STL-заголовочникам.
