---
layout: post
title: Haskell: что же это за ленивые вычисления такие?
category: articles
tags: [Haskell]
comments: true
share: true
---

Вот формальное определение:

**"Lazy evaluation is an evaluation strategy which delays the evaluation of an expression until its value is needed."**

Ну вроде бы всё понятно: откладываем вычисление выражения до тех пор, пока оно кому-то не понадобится. Но поскольку я привык думать концепциями языка C++, я не мог понять, где тут изюминка и как это проявляется на практике. И вот недавно, благодаря одному руководству по Haskell, я наконец-то вкурил. Как это обычно бывает, всё оказалось проще нежели я думал.

Итак, представьте себе, что у нас есть список из 100 одинаковых IP-адресов. Не важно, зачем нам могло бы понадобится такое в реальной жизни, но допустим... И вот нам потребовалось получить первые два из этих адресов с выводом их на консоль.

На C++ это выглядело бы примерно так:

```cpp
typedef std::vector<std::string> IP_addresses;

IP_addresses generate_addresses( size_t how_many ) {
    const IP_addresses addresses( how_many, "127.0.0.1" );
    assert( addresses.size() == how_many );
    return addresses;
}

void take_and_print( size_t how_many, const IP_addresses& addresses ) {
    for( size_t i = 0; i < how_many; ++i ) {
        std::cout << addresses[i] << std::endl;
    }
}

int main() {
    take_and_print( 2, generate_addresses( 100 ) );
}
```

Выводом этой программы будет:
<bash>
127.0.0.1
127.0.0.1
</bash>

Вопрос: сколько строк, соответствующих IP-адресам, было фактически создано функцией <code>generate_addresses()</code>? Разумеется, 100, о чём нам неопровержимо свидетельствует проверка с помощью <code>assert</code>. А теперь второй вопрос: сколько из этих 100 адресов фактически понадобилось внешнему контексту, а именно вызывающей функции <code>take_and_print()</code>? Только два первых.

Таким образом, мы можем констатировать, что раз уж из 100 созданных строк фактически потребовались лишь первые две, то оставшиеся 98 строк были созданы абсолютно напрасно. Было затрачено время на создание этих 98 строк, была затрачена память для их сохранения - и всё впустую.

Это - строгость вычислений, присущая языку C++. Функция <code>generate_addresses()</code> прямолинейна и сразу рвётся в бой. Сказали ей создать 100 адресов - получите 100. Скажут создать миллион - пожалуйста, вот вам миллион. Скажут миллиард - ну что ж, потерпите чуток, но будет вам и миллиард.

Тем временем функция <code>take_and_print()</code> столь же прямолинейна, и ей абсолютно наплевать на усилия трудолюбивой функции <code>generate_addresses()</code>. Если ей сказали отобразить лишь первые два элемента полученного контейнера, именно так она и сделает. И ей без разницы, сколько там *ещё* элементов в том контейнере, 2 или 2 миллиарда.

Результатом такой строгости является лишняя работа (в данном случае аж 98% оказались лишними). Но функции в языке Haskell, в отличие от трудолюбивых коллег из C++, терпеть не могут лишней работы.

Запустим интерпретатор **ghci** и напишем:
```haskell
> take 2 (replicate 100 "127.0.0.1")
["127.0.0.1","127.0.0.1"]
```

Эта строка делает всю ту же работу: функция <code>replicate</code> создаёт список из 100 строк с нашим IP-адресом и передаёт его в качестве второго аргумента функции <code>take</code>, которая в свою очередь берёт лишь первые два элемента из этого списка и выводит их.

Но весь фокус в том, что функция <code>replicate</code> *на самом деле* создаёт список вовсе не из 100 строк, а всего из двух. Почему? Потому что внешнему контексту нужно лишь две. :)

Функция <code>replicate</code> - лентяйка. Она как бы смотрит по сторонам и думает: "Так-с, кому тут нужны мои строки. Ага, функции <code>take</code> нужны. И сколько же? А-а, всего две. Ну так а чего я, глупая что ли, создавать сто, когда требуется всего две?! Вот тебе две и будь счастлива!" 

И несмотря на то, что трудолюбие - это хорошо, а лень - это плохо, в данном случае мне более симпатична функция-лентяйка. Она как хороший рационализатор, делает не столько, сколько её попросили, а столько, сколько реально необходимо. В этом и заключается суть ленивых вычислений в Haskell.

Разумеется, если аппетиты функции <code>take</code> возрастут и она попросит первые 50 элементов вместо первых двух, то функция <code>replicate</code> создаст список уже из 50 строк. Столько, сколько нужно, и ни капли больше.

Но внимательный читатель скажет мне: "Э-э, друг, погоди-ка! А откуда мне знать, что функция <code>replicate</code> действительно создаёт лишь столько IP-адресов, сколько нужно? Может, она каждый раз и создаёт 100 строк, как в C++! Докажи обратное!"

Что ж, с радостью докажу обратное. Дело в том, что в языке Haskell можно оперировать бесконечно большими списками. Нет, не просто очень большими, но именно бесконечными. Перепишем пример следующим образом:

```haskell
> take 2 (cycle ["127.0.0.1"])
```

Функция <code>cycle</code> создаёт бесконечно большой список на основе списка, полученного ею в качестве аргумента. В данном случае мы передали ей список из одной-единственной строки "127.0.0.1", а она создаст из него список с бесконечно большим количеством этих же строк.

И если бы наша трудолюбивая функция <code>generate_addresses</code> захотела стать похожей на свою ленивую коллегу, её пришлось бы переписать так:

```cpp
IP_addresses generate_addresses( size_t how_many ) {
    IP_addresses addresses;
    for(;;) {
        addresses.push_back( "127.0.0.1" );
    }
    return addresses;
}
```

Но мой внимательный читатель возразит: "Чё за бред! Это же зависнет намертво, пока процесс не будет убит!"

Конечно зависнет. И виной тому уже известное нам трудолюбие функции <code>generate_addresses</code>. Сказали создать бесконечно большой список - буду создавать до последнего вздоха.

Однако если мы выполним это:

```haskell
> take 2 (cycle ["127.0.0.1"])
["127.0.0.1","127.0.0.1"]
```

не будет никакого зависания, и результат мы получим правильный. Ну в самом деле, зачем создавать бесконечно длинный список, если в конечном итоге потребовались лишь первые два его элемента? То есть функция <code>cycle</code> начинает создавать бесконечно большой список, но создав лишь два первых его элемента, сразу останавливается, потому что понимает, что третий и все последующие элементы так никогда и не понадобятся...

Ах да, я и забыл, что мой читатель внимателен. Он может потребовать доказательств, что функция <code>cycle</code> действительно создаёт бесконечно большой список. Ну что ж, пусть выполнит это:

```haskell
> cycle ["127.0.0.1"])
```

Только пусть держит пальцы на Ctrl+C наготове, потому что на экран очень быстро посыпется очень много строчек... :)

Итак, вот простая суть ленивых вычислений в Haskell: не важно, сколько приказали сделать, ведь что в конечном итоге будет сделано лишь столько, сколько реально нужно.
