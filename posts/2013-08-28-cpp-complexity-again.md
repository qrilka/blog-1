---
layout: post
title: О сложности С++ замолвим слово... Ещё раз...
category: articles
tags: [C++, Objective-C]
comments: true
share: true
---

Сегодня прочёл одну **<a href="http://blog.greaterthanzero.com/post/58482859780/c-and-the-culture-of-complexity">заметку</a>** под названием "C++ and the Culture of Complexity". Суть её в том, что С++ избыточно сложен в сравнении со многим современными языками программирования. Ну и на волне этой заметки я хотел бы поразмышлять об одном аспекте, который сразу же бросился мне в глаза при изучении Objective-C.

Речь пойдёт о создании и манипулировании объектами пользовательских типов. Почему пользовательских? Потому что с типами **int** и ему подобными и так всё понятно: они мгновенно создаются, столь же мгновенно и безопасно копируются, да и вообще проблем с ними как правило не возникает. Поэтому говорить будем именно о типах, созданных пользователем.

Известно, что в C++ объект пользовательского типа может быть создан самыми разными способами:
```cpp
class My {
    // ...
};

My my_global; // Можно так...

int main() {
    My my; // Можно так...
    My* my_in_heap( new My() ); // Или так...
    static My my_static; // Или даже так...
}
```

В общем, как хотим так и создаём. Гибкость с большой буквы. А теперь вопрос: чем является эта гибкость, благом или злом? И чтобы ответить на этот вопрос, мы должны рассмотреть *использование* созданного объекта. А использовать этот самый объект в C++ можно тоже различными способами:
```cpp
void by_value( My m ) { /* Передаём по значению... */ }

void by_ptr( My* m ) { /* Передаём по указателю... */ }

void by_classic_cref( const My& m ) { /* Передаём по классической константной ссылке... */ }

void by_classic_ref( My& m ) { /* Передаём по классической ссылке... */ }

My return_by_value() {
    My my;
    return my; // Возвращаем по значению...
}

My& return_by_classic_ref() {
    My my;
    return my; // Глупо, но ведь можно...
}

My* return_by_ptr() {
    return new My(); // Возвращаем по указателю...
}
```

И тут тоже сплошная гибкость.

С одной стороны, это хорошо. Например, если пользовательский тип относительно прост (уровня несложной С-подобной структуры), то его создание в стеке займёт меньше времени чем в куче. Конечно, в реальности эта разница (особенно на современном компьютере) никак себя не проявит, но если вдруг объект нужно создавать и уничтожать, скажем, миллион раз в секунду, то об этом можно задуматься...

С другой же стороны, использование объекта разными способами влечёт (вернее, может повлечь) за собой несколько мааааленьких сложностей, таких как побочное копирование или мёртвая ссылка. Передаёте по значению - получите <del>ненужную</del> временную копию. Возвращаете по ссылке объект, который (уже) разрушен - получите проблемы с памятью. К тому же, говоря о копировании, нельзя не вспомнить копирующий конструктор, и едва ли есть хотя бы один программист С++, избежавший проблем с этим зверем. :)

Да, я знаю классический ответ, ибо и сам многократно так отвечал: *"Будьте внимательней! Если вам не нужна временная копия - передавайте объект по ссылке. Если вам нужно правильное глубокое копирование - определяйте собственный копирующий конструктор."* Однако в суровой реальности мы все наступали на эти грабли (лично я наступал на них неоднократно). Казалось бы, разве мы не знаем о том, что нужно быть внимательным? Разве мы не знаем разницу между передачей по значению и по ссылке? Конечно знаем. Но...

Но давайте задумаемся: а нужна ли сия вышеупомянутая гибкость? Лично я прихожу к выводу, что не нужна.

Во-первых, практику создания и использования объекта по значению, по ссылке и по указателю необходимо изучать *всем* новичкам С++, таким образом время изучения языка увеличивается (только не говорите мне, что эту тему новичок освоит за пару дней). Во-вторых, ошибки в этой области зачастую не могут быть обнаружены компилятором (впрочем, при флаге -pedantic могут всплывать вспомогательные предупреждения). И в-третьих, эта гибкость привносит в язык <del>ненужную</del> избыточную сложность.

Почему избыточную? Потому что можно обойтись и без неё. Пример тому - Objective-C. Известно, что как C++, так и Objective-C переняли многие черты своего общего предка - языка С. Но создатели Objective-C кое-что упростили.

Для меня было приятным сюрпризом узнать, что в Objective-C объект невстроенного типа невозможно создать иначе, как в куче. Таким образом, мы имеем только указатель, и работать с объектом мы можем исключительно через него. Принимаем - по указателю, возвращаем - по указателю. Сначала мне показалось это не очень гибким, но потом я понял, что это даже хорошо.

Более того, при попытке нарушить этот принцип разработчик незамедлительно получает ошибку. Не предупреждение, которое можно не заметить или проигнорировать, но именно ошибку.
<m>
@interface Message
-(void) check: (NSString) header;
@end

@implementation Message
-(void) check: (NSString) header {
    // Какой-то код...
}
@end
</m>

Здесь мы определяем собственный тип **Message**, один из методов которого принимает в качестве аргумента объект типа **NSString** (стандартная строка). Как видите, метод принимает строку по значению. В результате получаем ошибку:

**Interface type 'NSString' cannot be passed by value; did you forget * in 'NSString'?**

Не просто ошибка, но и сразу же подсказка к её исправлению. Та же ситуация при попытке вернуть по значению:
<m>
@interface Message
-(NSString) header;
@end

@implementation Message
-(NSString) header {
    // Какой-то код...
}
@end
</m>

Компилятор грозно сообщает:

**Interface type 'NSString' cannot be returned by value; did you forget * in 'NSString'?**

Попробуем неправильно создать объект:
<m>
static void testMessage() {
    Message m; // Создаём в стеке... Ну-ну...
}
</m>

В этом случае компилятор опять даст нам по башке:

**Interface type cannot be statically allocated**

Таким образом, работаем только с указателем, и никак иначе. Ссылок же в Objective-C нет и вовсе. Да и с копированием тоже всё строго:
<m>
static void testMessages(Message* m1, Message* m2) {
    *m1 = *m2; // Разыменовываем указатели с попыткой присвоения? Ну-ну...
}
</m>

И вновь - ошибка:

**Cannot assign to class object ('Message' invalid)**

То есть никакого неправильного копирования объекта не может быть в принципе. Кстати, понятие "копирующий конструктор" языку Objective-C тоже незнакомо...

К чему это я? Да к тому, что единый способ создания объекта (а именно в куче) и единый способ работы с ним (исключительно по указателю) видится мне значительно лучшей альтернативой той гибкости, которую предлагает C++.
