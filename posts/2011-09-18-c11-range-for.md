---
layout: post
title: C++11: анализ range-for
category: articles
tags: [C++]
comments: true
share: true
---

Итак, сподобившись-таки поставить **g++ 4.6.0** (подробности **<a href="http://dshevchenko.biz/ru/content/gcc-два-компилятора-вместе">тут</a>**), я решил испытать новый **range for** цикл и проверить его эффективность.

Итак, имеем код:
```cpp
int main() {
    std::vector< unsigned long int > v;
    for ( size_t i = 0; i < 10000000; ++i ) {
        v.push_back( i );
    }
    BOOST_ASSERT ( 10000000 == v.size() );
    
    // Начало временнОго замера 1.
    BOOST_FOREACH ( auto i, v ) {
        const unsigned long int ii = i; // Условная работа.
    }
    // Конец временнОго замера 1.

    // Начало временнОго замера 2.
    for ( auto it = v.begin(); it != v.end(); ++it ) {
        const unsigned long int ii = *it; // Условная работа.
    }
    // Конец временнОго замера 2.

    // Начало временнОго замера 3.
    for ( auto i : v ) {
        const unsigned long int ii = i; // Условная работа.
    }
    // Конец временнОго замера 3.
}
```
Итак, результаты замеров следующие (огрублённые):
<pre>
1. 390 мс
2. 200 мс
3. 140 мс
</pre>
Ну и как вам? Оказывается, C++0x предоставляет не только наиболее удобный цикл, но и наиболее эффективный.

Ну что ж, многообещающе...
