---
title: GCC: два компилятора вместе
tags: gcc
---

Причины, подвигшие меня к установке **g++ 4.6.0**, просты: поддержка C++0x. Данная версия вышла 25 марта (любопытное совпадение: именно в этот день Комитетом по стандартизации был принят FDIS), и именно этой версией поддерживается наибольшее число возможностей нового языка.

Но в моей системе (Debain Linux Squeeze), естественно, уже стоял компилятор версии 4.4.5. Значит, нужно ставить в параллель.<br/>
<h3>Что нам понадобится?</h3>

Собственно, сам компилятор. Напомню, что GCC - это семейство компиляторов для разных языков. Но нас интересует только С++, поэтому скачиваем следующие пакеты:

```
ftp://ftp.gnu.org/gnu/gcc/gcc-4.6.0/gcc-core-4.6.0.tar.bz2 - ядро компилятора.
ftp://ftp.gnu.org/gnu/gcc/gcc-4.6.0/gcc-g++-4.6.0.tar.bz2 - собственно g++.
```

Но это ещё не всё. Нам понадобятся также три служебные библиотеки - GMP, MPC и MPFR:

```
ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-4.3.2.tar.bz2
ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz
ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2<br/>
```

<h3>Подготовка пути</h3>

Кладём все архивы в некую папку, она будет корнем установки нового компилятора. В моей системе это /home/denis/Distros/GCC/. Этот путь будет использован в качестве установочного префикса при сборке. Для краткости далее будем именовать его **INSTALL_PATH**.<br/>
<h3>Подготовка компилятора</h3>

Распаковываем **gcc-core-4.6.0.tar.bz2** и получаем папку **gcc-4.6.0**. А вот теперь есть одна хитрость. Дело в том, что когда мы распакуем **gcc-g++-4.6.0.tar.bz2**, то получится такая же папка **gcc-4.6.0**. Поэтому я разношу их при распаковке в разные места.

Захожу в папку **gcc-4.6.0**, полученную при распаковке **gcc-g++-4.6.0.tar.bz2** и вижу там две папки: **gcc** и **libstdc++-v3**. Теперь:
<ol>
 <li>папку **libstdc++-v3** копирую в корень папки **gcc-4.6.0**, полученной при распаковке **gcc-core-4.6.0.tar.bz2**.</li>
 <li>в папке gcc берём папку cp и копируем её в подпапку gcc папки **gcc-4.6.0**, полученной при распаковке **gcc-core-4.6.0.tar.bz2**.</li>
</ol>
Итак, мы получили одну папку **gcc-4.6.0**, в которой есть всё необходимое для сборки. Та папка **gcc-4.6.0**, которая была получена их архива **gcc-g++-4.6.0.tar.bz2**, нам больше не нужна.<br/>
<h3>Сборка служебных библиотек</h3>

Теперь распаковываем архивы трёх вышеупомянутых служебных библиотек. Их необходимо собрать и установить ***перед*** сборкой компилятора.

Более того, важен порядок их сборки, поскольку они зависят друг от друга.

Первой собираем GMP. Не забываем указать упомянутый выше префикс установки:
```bash
$ ./configure --prefix=INSTALL_PATH
```
Потом make и make install.

Далее собираем MPFR. Указываем установочный префикс и путь к (уже) установленной GMP:
```bash
$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH
```
Потом make и make install.

Последней собираем MPC. Указываем установочный префикс, а также пути к (уже) установленным GMP и MPFR:
```bash
$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH --with-mpfr=INSTALL_PATH
```
Потом make и make install.

Итак, служебные библиотеки собраны.<br/>
<h3>Сборка компилятора</h3>

Указываем установочный префикс и пути к (уже) установленным служебным библиотекам:
```bash
$ ./configure --prefix=INSTALL_PATH --with-gmp=INSTALL_PATH --with-mpfr=INSTALL_PATH --with-mpc=INSTALL_PATH
```

Далее make. Начинается компиляция компилятора (приколько звучит).<br/>
<h3>Подводный камень №1</h3>

Вы думаете, что всё скомпилируется и готово? Не тут-то было. Компиляция прервётся с ошибкой. А причина в том, что мы забыли передать путь к служебным библиотекам линковщику, а в процессе сборки они понадобятся. Поэтому пропишем путь INSTALL_PATH/lib в **/etc/ld.so.conf**. Не забываем выполнить магическое **ldconfig**.

После этого снова make. Компиляция продолжится.<br/>
<h3>Подводный камень №2</h3>

Ну теперь-то всё? Нет, не всё. Если у вас 64-разрядная система (как у меня), то компиляция снова прервётся. Причина в отсутствии файла **/usr/include/gnu/stubs-32.h**. Если вы посмотрите, то файл stubs-64.h имеется, а stubs-32.h отсутствует. Чтобы это исправить, необходимо установить пакет **libc6-dev-i386**. В репозитории Debian такой имеется. После этого требуемый файл появится.

После этого снова make. Компиляция продолжится.<br/>
<h3>Подводный камень №3</h3>

Итак, компиляция завершена. К слову сказать, займёт она довольно много времени. На моей системе с Corei3 2.4Ггц и 2 Гб DDR3 памяти компиляция забрала часа полтора.

После этого вы делаете make install. И в INSTALL_PATH появятся несколько дополнительных папок, такие как lib32, lib64, bin, libexec, share.

И вот вы, в предвкушении испытаний, пишете свой hello world и скармливаете его новому компилятору. Компиляция проходит успешно, только вот запустить программу не удастся. Причина проста: стандартная библиотека.

Проверим:
```bash
$ ldd my_program
    ...
    libstdc++.so.6 => /usr/lib/libstdc++.so.6  
    ...
```

Итак, причина в том, что стандартная библиотека С++ берётся из старого пути, из **/usr/lib**. Но ведь там лежит библиотека, используемая нашим "старым" компилятором (в моём случае g++ 4.4.5). А нам нужна новая библиотека, собранная с новым компилятором.

Решение простое: пропишем путь к новой стандартной библиотеке INSTALL_PATH/lib64 (для 64-разрядной системы) в **/etc/ld.so.conf.d/libc.conf**. Я у себя прописал этот путь первым по счёту в данном файле.

После этого снова компилируем программу, и проверяем вновь:
```bash
$ ldd my_program
    ...
    libstdc++.so.6 => INSTALL_PATH/lib64/libstdc++.so.6  
    ...
```

Теперь используется новая стандартная библиотека, как нам и нужно.<br/>
<h3>Завершение</h3>

Ну что ж, сборка и настройка завершена. В подтверждение этому попробуем скомпилировать программу с новейшими возможностями стандарта. В частности, проверим range for. Разумеется, необходимо также указать флаг **-std=c++0x**, всё-таки поддержка нового стандарта носит (формально) экспериментальный характер.

```cpp
int main() {
    std::vector< int > v = { 1, 2, 3 };
    for ( auto i : v ) {
        std::cout << i << std::endl;
    }
}
```

Итак, как видите, всё работает. Теперь в нашей системе есть два компилятора, и мы можем продолжить наши эксперименты с новейшими возможностями C++0x.
