---
title: C/C++: когда же умрёт эта связка?..
tags: C, C++
---

До сих пор на просторах Интернета и на обложках книг красуется эта многолетняя связка: C/C++. Вы тоже замечали её, не так ли? "Программирование на C/C++", "Статьи о C/C++", "Требуется программист C/C++" и т.п.

На дворе 2011 год, а C++ до сих пор воспринимается как продолжение языка C.

Почему-то программист C, знакомый со словами **class** и **template**, уже считает себя программистом C++.

Почему-то на собеседовании на вакансию "Программист C++" соискателю задаются вопросы по ручному управлению памятью и "сырым" указателям (то есть вопросы для программиста C, но не C++).

Почему-то до сих пор бытует мнение (и оно довольно сильно), в соответствии с которым изучению C++ обязательно (или очень желательно) должно предшествовать изучение C.

Историческая преемственность C++ от C была неизбежностью, но в последствии она сыграла двоякую роль. С одной стороны, C++ наследовал от C потрясающую эффективность выполнения, и это хорошо. Но с другой стороны, C++ до сих пор не воспринимается многими так, как он **должен** восприниматься - как *отдельный язык программирования*.

Язык с собственной философией и собственным стандартом. Язык, который во многом уже не совместим с C (причём как в одну, так и в другую сторону). Язык, требующий особого мышления.

C++ и C ни в коем случае нельзя сравнивать с позиции "лучше/хуже". Это разные языки программирования. Да, синтаксически они схожи, да, во многом остаются совместимыми, да, они до сих пор короли системного программирования - и всё-таки они разные.

Да, базовое представление о C иметь полезно. Например, в том случае, если программисту необходимо использовать стороннюю C-шную библиотеку. Но утверждать, что программист C++ **обязан** знать глубокое копирование с сырыми указателями в классе - это чушь. Если он будет это знать - хорошо, но если не знает - ничего страшного. Я вот, например, не использую в своём коде сырые указатели. Вообще. И зачем же мне знать то, что я не использую? В конце концов, если мне это вдруг и понадобится, я освежу свою память парочкой тестовых программок - и готово.

Я очень надеюсь, что введение нового стандарта C++11 как никогда ранее приблизит тот светлый миг, когда многолетняя связка "C/C++" будет забыта навсегда...
