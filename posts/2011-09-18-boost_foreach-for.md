---
title: BOOST_FOREACH или for
tags: boost, C++, эффективность
---

Итак, что же использовать? Проведём честный анализ. Критерия будет два: удобство кода (во всех смыслах слова) и эффективность его выполнения.

Во всех примерах для простоты будем использовать ставший уже классикой **std::vector< int >** и его typedef-псевдоним:
```cpp
typedef std::vector< int > V;
```

<h3>Удобство кода</h3>

Сравним:
```cpp
V v;
for ( V::iterator it = v.begin(); it != v.end(); ++it ) {
    std::cout << *it << std::endl;
}
```и
```cpp
V v;
BOOST_FOREACH ( int i, v ) {
    std::cout << i << std::endl;
}
```
Режьте меня на части, но я убеждён: второй код удобнее первого. Добавим typedef-улучшение:
```cpp
V v;
typedef V::iterator Vit;
for ( Vit it = v.begin(); it != v.end(); ++it ) {
    std::cout << *it << std::endl;
}
```
Лучше, но код возрос на одну строку.

Однако дело, конечно, не в typedef и не в том, что цикл for требует чуть большего по объёму кода. Дело в том, что в итеративном цикле легче допустить ошибку. Например:
```cpp
V v;
typedef V::iterator Vit;
for ( Vit it = v.begin(); it != v.begin(); ++it ) {
    std::cout << *it << std::endl;
}
```или
```cpp
V v;
typedef V::iterator Vit;
for ( Vit it = v.begin(); it != v2.end(); ++it ) {
    std::cout << *it << std::endl;
}
```
В первом случае мы передали один и тот же итератор v.begin(), а во втором случае в наш код влез другой контейнер v2 (из той же области видимости, и того же типа). Компилятор не покажет вам этих проблем, поскольку это не проблемы языка, это ваши проблемы.

Скажете, что вы никогда не допустите таких глупых ошибок? Ну-ну, я тоже так думал когда-то... :)

В BOOST_FOREACH взаимодействия с итераторами нет, значит и ошибиться невозможно.

<h3>Эффективность выполнения</h3>

Итак, с красотой кода разобрались, но что со временем выполнения? Некоторые говорят, мол, в силу того, что BOOST_FOREACH - это макрос, он разворачивается на стадии препроцессирования в монстроподобную конструкцию и, мол, как это ужасно.

Ну, во-первых, во что он там разворачивается - это не мои заботы, об этом пусть думает компилятор. Увеличивается размер исполняемого файла? Ну и пусть увеличивается, для меня это не проблема.

Однако вопрос эффективности может быть действительно важен. Его и рассмотрим.

Проведём серию экспериментов. Используемая система:

* Debian Linux 6.0 amd64
* Corei3 M-370 2.4 ГГц
* g++ 4.4.5

Итак:
```cpp
typedef std::vector< int > V;

inline void time_stamp() {
    using namespace boost::posix_time;
    std::cout << to_simple_string( microsec_clock::universal_time() ) << std::endl; 
}

inline void fill_container( V& v ) {
    const size_t max = 10000000;
    for ( size_t i = 0; i < max; ++i ) {
        v.push_back( i );
    }
    BOOST_ASSERT ( max == v.size() );
}

int main() {
    V v;
    fill_container( v );
    
    time_stamp();
    BOOST_FOREACH ( int i, v ) {
        const int ii = i; // Ну, хоть какая-то работа...
    }
    time_stamp();

    return 0;
}
```
Вывод этого кода:
2011-Mar-15 08:01:04.421968
2011-Mar-15 08:01:04.842156

При повторении запусков выясняю среднее огрублённое время цикла: **421 мс**.

Теперь изменим код цикла:
```cpp
...
int main() {
    V v;
    fill_container( v );
    
    time_stamp();
    for ( V::iterator it = v.begin(); it != v.end(); ++it ) {
        const int ii = i; // Ну, хоть какая-то работа...
    }
    time_stamp();

    return 0;
}
```
Вывод этого кода:
2011-Mar-15 08:26:21.014594
2011-Mar-15 08:26:21.244632

При повторении запусков выясняю среднее огрублённое время цикла: **229 мс**.

Ага, ликуют поклонники цикла for, мы победили! Да, победа очевидна, ибо если очень огрубить, то можно сказать, что итеративный for выполняется почти в два раза быстрее.

НО! Учтите, что цикл состоял из десяти миллионов итераций. Значит, время **одной** итерации в первом случае составил 42 нс, а во втором - 23 нс. То есть проигрыш одной итерации - менее 20 нс.

Вывод: при переборе действительно больших контейнеров, особенно когда время перебора критично, BOOST_FOREACH в проигрыше. Но для перебора (критически важного по скорости) лучше использовать стандартные алгоритмы, а не циклы.

Поэтому для большинства случаев BOOST_FOREACH - однозначно лучший выбор.
